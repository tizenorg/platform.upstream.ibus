/* separator.c generated by valac 0.20.1, the Vala compiler
 * generated from separator.vala, do not modify */

/* vim:set et sts=4 sw=4:
 *
 * ibus - The Input Bus
 *
 * Copyright(c) 2011 Peng Huang <shawn.p.huang@gmail.com>
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2.1 of the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301
 * USA
 */

#include <glib.h>
#include <glib-object.h>
#include <gtk/gtk.h>


#define TYPE_HSEPARATOR (hseparator_get_type ())
#define HSEPARATOR(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_HSEPARATOR, HSeparator))
#define HSEPARATOR_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_HSEPARATOR, HSeparatorClass))
#define IS_HSEPARATOR(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_HSEPARATOR))
#define IS_HSEPARATOR_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_HSEPARATOR))
#define HSEPARATOR_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_HSEPARATOR, HSeparatorClass))

typedef struct _HSeparator HSeparator;
typedef struct _HSeparatorClass HSeparatorClass;
typedef struct _HSeparatorPrivate HSeparatorPrivate;

#define TYPE_VSEPARATOR (vseparator_get_type ())
#define VSEPARATOR(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_VSEPARATOR, VSeparator))
#define VSEPARATOR_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_VSEPARATOR, VSeparatorClass))
#define IS_VSEPARATOR(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_VSEPARATOR))
#define IS_VSEPARATOR_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_VSEPARATOR))
#define VSEPARATOR_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_VSEPARATOR, VSeparatorClass))

typedef struct _VSeparator VSeparator;
typedef struct _VSeparatorClass VSeparatorClass;
typedef struct _VSeparatorPrivate VSeparatorPrivate;

struct _HSeparator {
	GtkHSeparator parent_instance;
	HSeparatorPrivate * priv;
};

struct _HSeparatorClass {
	GtkHSeparatorClass parent_class;
};

struct _VSeparator {
	GtkVSeparator parent_instance;
	VSeparatorPrivate * priv;
};

struct _VSeparatorClass {
	GtkVSeparatorClass parent_class;
};


static gpointer hseparator_parent_class = NULL;
static gpointer vseparator_parent_class = NULL;

GType hseparator_get_type (void) G_GNUC_CONST;
enum  {
	HSEPARATOR_DUMMY_PROPERTY
};
HSeparator* hseparator_new (void);
HSeparator* hseparator_construct (GType object_type);
GType vseparator_get_type (void) G_GNUC_CONST;
enum  {
	VSEPARATOR_DUMMY_PROPERTY
};
VSeparator* vseparator_new (void);
VSeparator* vseparator_construct (GType object_type);


HSeparator* hseparator_construct (GType object_type) {
	HSeparator * self = NULL;
	self = (HSeparator*) g_object_new (object_type, "margin", 2, NULL);
	return self;
}


HSeparator* hseparator_new (void) {
	return hseparator_construct (TYPE_HSEPARATOR);
}


static void hseparator_class_init (HSeparatorClass * klass) {
	hseparator_parent_class = g_type_class_peek_parent (klass);
}


static void hseparator_instance_init (HSeparator * self) {
}


GType hseparator_get_type (void) {
	static volatile gsize hseparator_type_id__volatile = 0;
	if (g_once_init_enter (&hseparator_type_id__volatile)) {
		static const GTypeInfo g_define_type_info = { sizeof (HSeparatorClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) hseparator_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (HSeparator), 0, (GInstanceInitFunc) hseparator_instance_init, NULL };
		GType hseparator_type_id;
		hseparator_type_id = g_type_register_static (GTK_TYPE_HSEPARATOR, "HSeparator", &g_define_type_info, 0);
		g_once_init_leave (&hseparator_type_id__volatile, hseparator_type_id);
	}
	return hseparator_type_id__volatile;
}


VSeparator* vseparator_construct (GType object_type) {
	VSeparator * self = NULL;
	self = (VSeparator*) g_object_new (object_type, "margin", 2, NULL);
	return self;
}


VSeparator* vseparator_new (void) {
	return vseparator_construct (TYPE_VSEPARATOR);
}


static void vseparator_class_init (VSeparatorClass * klass) {
	vseparator_parent_class = g_type_class_peek_parent (klass);
}


static void vseparator_instance_init (VSeparator * self) {
}


GType vseparator_get_type (void) {
	static volatile gsize vseparator_type_id__volatile = 0;
	if (g_once_init_enter (&vseparator_type_id__volatile)) {
		static const GTypeInfo g_define_type_info = { sizeof (VSeparatorClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) vseparator_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (VSeparator), 0, (GInstanceInitFunc) vseparator_instance_init, NULL };
		GType vseparator_type_id;
		vseparator_type_id = g_type_register_static (GTK_TYPE_VSEPARATOR, "VSeparator", &g_define_type_info, 0);
		g_once_init_leave (&vseparator_type_id__volatile, vseparator_type_id);
	}
	return vseparator_type_id__volatile;
}



