/* property.c generated by valac 0.20.1, the Vala compiler
 * generated from property.vala, do not modify */

/* vim:set et sts=4 sw=4:
 *
 * ibus - The Input Bus
 *
 * Copyright(c) 2011 Peng Huang <shawn.p.huang@gmail.com>
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2.1 of the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301
 * USA
 */

#include <glib.h>
#include <glib-object.h>
#include <ibus.h>
#include <gtk/gtk.h>
#include <stdlib.h>
#include <string.h>
#include <gobject/gvaluecollector.h>


#define TYPE_PROPERTY_MANAGER (property_manager_get_type ())
#define PROPERTY_MANAGER(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_PROPERTY_MANAGER, PropertyManager))
#define PROPERTY_MANAGER_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_PROPERTY_MANAGER, PropertyManagerClass))
#define IS_PROPERTY_MANAGER(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_PROPERTY_MANAGER))
#define IS_PROPERTY_MANAGER_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_PROPERTY_MANAGER))
#define PROPERTY_MANAGER_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_PROPERTY_MANAGER, PropertyManagerClass))

typedef struct _PropertyManager PropertyManager;
typedef struct _PropertyManagerClass PropertyManagerClass;
typedef struct _PropertyManagerPrivate PropertyManagerPrivate;
#define _g_object_unref0(var) ((var == NULL) ? NULL : (var = (g_object_unref (var), NULL)))

#define TYPE_PROP_CHECK_MENU_ITEM (prop_check_menu_item_get_type ())
#define PROP_CHECK_MENU_ITEM(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_PROP_CHECK_MENU_ITEM, PropCheckMenuItem))
#define PROP_CHECK_MENU_ITEM_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_PROP_CHECK_MENU_ITEM, PropCheckMenuItemClass))
#define IS_PROP_CHECK_MENU_ITEM(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_PROP_CHECK_MENU_ITEM))
#define IS_PROP_CHECK_MENU_ITEM_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_PROP_CHECK_MENU_ITEM))
#define PROP_CHECK_MENU_ITEM_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_PROP_CHECK_MENU_ITEM, PropCheckMenuItemClass))

typedef struct _PropCheckMenuItem PropCheckMenuItem;
typedef struct _PropCheckMenuItemClass PropCheckMenuItemClass;

#define TYPE_PROP_RADIO_MENU_ITEM (prop_radio_menu_item_get_type ())
#define PROP_RADIO_MENU_ITEM(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_PROP_RADIO_MENU_ITEM, PropRadioMenuItem))
#define PROP_RADIO_MENU_ITEM_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_PROP_RADIO_MENU_ITEM, PropRadioMenuItemClass))
#define IS_PROP_RADIO_MENU_ITEM(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_PROP_RADIO_MENU_ITEM))
#define IS_PROP_RADIO_MENU_ITEM_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_PROP_RADIO_MENU_ITEM))
#define PROP_RADIO_MENU_ITEM_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_PROP_RADIO_MENU_ITEM, PropRadioMenuItemClass))

typedef struct _PropRadioMenuItem PropRadioMenuItem;
typedef struct _PropRadioMenuItemClass PropRadioMenuItemClass;

#define TYPE_IPROP_ITEM (iprop_item_get_type ())
#define IPROP_ITEM(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_IPROP_ITEM, IPropItem))
#define IS_IPROP_ITEM(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_IPROP_ITEM))
#define IPROP_ITEM_GET_INTERFACE(obj) (G_TYPE_INSTANCE_GET_INTERFACE ((obj), TYPE_IPROP_ITEM, IPropItemIface))

typedef struct _IPropItem IPropItem;
typedef struct _IPropItemIface IPropItemIface;

#define TYPE_PROP_IMAGE_MENU_ITEM (prop_image_menu_item_get_type ())
#define PROP_IMAGE_MENU_ITEM(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_PROP_IMAGE_MENU_ITEM, PropImageMenuItem))
#define PROP_IMAGE_MENU_ITEM_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_PROP_IMAGE_MENU_ITEM, PropImageMenuItemClass))
#define IS_PROP_IMAGE_MENU_ITEM(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_PROP_IMAGE_MENU_ITEM))
#define IS_PROP_IMAGE_MENU_ITEM_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_PROP_IMAGE_MENU_ITEM))
#define PROP_IMAGE_MENU_ITEM_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_PROP_IMAGE_MENU_ITEM, PropImageMenuItemClass))

typedef struct _PropImageMenuItem PropImageMenuItem;
typedef struct _PropImageMenuItemClass PropImageMenuItemClass;

#define TYPE_PROP_SEPARATOR_MENU_ITEM (prop_separator_menu_item_get_type ())
#define PROP_SEPARATOR_MENU_ITEM(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_PROP_SEPARATOR_MENU_ITEM, PropSeparatorMenuItem))
#define PROP_SEPARATOR_MENU_ITEM_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_PROP_SEPARATOR_MENU_ITEM, PropSeparatorMenuItemClass))
#define IS_PROP_SEPARATOR_MENU_ITEM(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_PROP_SEPARATOR_MENU_ITEM))
#define IS_PROP_SEPARATOR_MENU_ITEM_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_PROP_SEPARATOR_MENU_ITEM))
#define PROP_SEPARATOR_MENU_ITEM_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_PROP_SEPARATOR_MENU_ITEM, PropSeparatorMenuItemClass))

typedef struct _PropSeparatorMenuItem PropSeparatorMenuItem;
typedef struct _PropSeparatorMenuItemClass PropSeparatorMenuItemClass;
typedef struct _ParamSpecPropertyManager ParamSpecPropertyManager;
typedef struct _PropImageMenuItemPrivate PropImageMenuItemPrivate;

#define TYPE_ICON_WIDGET (icon_widget_get_type ())
#define ICON_WIDGET(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_ICON_WIDGET, IconWidget))
#define ICON_WIDGET_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_ICON_WIDGET, IconWidgetClass))
#define IS_ICON_WIDGET(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_ICON_WIDGET))
#define IS_ICON_WIDGET_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_ICON_WIDGET))
#define ICON_WIDGET_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_ICON_WIDGET, IconWidgetClass))

typedef struct _IconWidget IconWidget;
typedef struct _IconWidgetClass IconWidgetClass;
typedef struct _PropCheckMenuItemPrivate PropCheckMenuItemPrivate;
typedef struct _PropRadioMenuItemPrivate PropRadioMenuItemPrivate;
typedef struct _PropSeparatorMenuItemPrivate PropSeparatorMenuItemPrivate;
#define _vala_assert(expr, msg) if G_LIKELY (expr) ; else g_assertion_message_expr (G_LOG_DOMAIN, __FILE__, __LINE__, G_STRFUNC, msg);

struct _PropertyManager {
	GTypeInstance parent_instance;
	volatile int ref_count;
	PropertyManagerPrivate * priv;
};

struct _PropertyManagerClass {
	GTypeClass parent_class;
	void (*finalize) (PropertyManager *self);
};

struct _PropertyManagerPrivate {
	IBusPropList* m_props;
};

struct _IPropItemIface {
	GTypeInterface parent_iface;
	void (*update_property) (IPropItem* self, IBusProperty* prop);
};

struct _ParamSpecPropertyManager {
	GParamSpec parent_instance;
};

struct _PropImageMenuItem {
	GtkImageMenuItem parent_instance;
	PropImageMenuItemPrivate * priv;
};

struct _PropImageMenuItemClass {
	GtkImageMenuItemClass parent_class;
};

struct _PropImageMenuItemPrivate {
	IBusProperty* m_property;
};

struct _PropCheckMenuItem {
	GtkRadioMenuItem parent_instance;
	PropCheckMenuItemPrivate * priv;
};

struct _PropCheckMenuItemClass {
	GtkRadioMenuItemClass parent_class;
};

struct _PropCheckMenuItemPrivate {
	IBusProperty* m_property;
};

struct _PropRadioMenuItem {
	PropCheckMenuItem parent_instance;
	PropRadioMenuItemPrivate * priv;
};

struct _PropRadioMenuItemClass {
	PropCheckMenuItemClass parent_class;
};

struct _PropSeparatorMenuItem {
	GtkSeparatorMenuItem parent_instance;
	PropSeparatorMenuItemPrivate * priv;
};

struct _PropSeparatorMenuItemClass {
	GtkSeparatorMenuItemClass parent_class;
};

struct _PropSeparatorMenuItemPrivate {
	IBusProperty* m_property;
};


static gpointer property_manager_parent_class = NULL;
static gpointer prop_image_menu_item_parent_class = NULL;
static IPropItemIface* prop_image_menu_item_iprop_item_parent_iface = NULL;
static gpointer prop_check_menu_item_parent_class = NULL;
static IPropItemIface* prop_check_menu_item_iprop_item_parent_iface = NULL;
static gpointer prop_radio_menu_item_parent_class = NULL;
static gpointer prop_separator_menu_item_parent_class = NULL;
static IPropItemIface* prop_separator_menu_item_iprop_item_parent_iface = NULL;

gpointer property_manager_ref (gpointer instance);
void property_manager_unref (gpointer instance);
GParamSpec* param_spec_property_manager (const gchar* name, const gchar* nick, const gchar* blurb, GType object_type, GParamFlags flags);
void value_set_property_manager (GValue* value, gpointer v_object);
void value_take_property_manager (GValue* value, gpointer v_object);
gpointer value_get_property_manager (const GValue* value);
GType property_manager_get_type (void) G_GNUC_CONST;
#define PROPERTY_MANAGER_GET_PRIVATE(o) (G_TYPE_INSTANCE_GET_PRIVATE ((o), TYPE_PROPERTY_MANAGER, PropertyManagerPrivate))
enum  {
	PROPERTY_MANAGER_DUMMY_PROPERTY
};
void property_manager_ProperyManager (PropertyManager* self);
void property_manager_set_properties (PropertyManager* self, IBusPropList* props);
gint property_manager_create_menu_items (PropertyManager* self, GtkMenu* menu);
static gint property_manager_create_menu_items_internal (PropertyManager* self, IBusPropList* props, GtkMenu* menu);
GType prop_check_menu_item_get_type (void) G_GNUC_CONST;
GType prop_radio_menu_item_get_type (void) G_GNUC_CONST;
GType iprop_item_get_type (void) G_GNUC_CONST;
PropImageMenuItem* prop_image_menu_item_new (IBusProperty* property);
PropImageMenuItem* prop_image_menu_item_construct (GType object_type, IBusProperty* property);
GType prop_image_menu_item_get_type (void) G_GNUC_CONST;
PropCheckMenuItem* prop_check_menu_item_new (IBusProperty* property);
PropCheckMenuItem* prop_check_menu_item_construct (GType object_type, IBusProperty* property);
PropRadioMenuItem* prop_radio_menu_item_new (IBusProperty* property, PropRadioMenuItem* group_source);
PropRadioMenuItem* prop_radio_menu_item_construct (GType object_type, IBusProperty* property, PropRadioMenuItem* group_source);
PropSeparatorMenuItem* prop_separator_menu_item_new (IBusProperty* property);
PropSeparatorMenuItem* prop_separator_menu_item_construct (GType object_type, IBusProperty* property);
GType prop_separator_menu_item_get_type (void) G_GNUC_CONST;
static void ____lambda16_ (PropertyManager* self, const gchar* k, gint s);
static void _____lambda16__iprop_item_property_activate (IPropItem* _sender, const gchar* key, gint state, gpointer self);
void property_manager_update_property (PropertyManager* self, IBusProperty* prop);
PropertyManager* property_manager_new (void);
PropertyManager* property_manager_construct (GType object_type);
static void g_cclosure_user_marshal_VOID__STRING_INT (GClosure * closure, GValue * return_value, guint n_param_values, const GValue * param_values, gpointer invocation_hint, gpointer marshal_data);
static void property_manager_finalize (PropertyManager* obj);
void iprop_item_update_property (IPropItem* self, IBusProperty* prop);
#define PROP_IMAGE_MENU_ITEM_GET_PRIVATE(o) (G_TYPE_INSTANCE_GET_PRIVATE ((o), TYPE_PROP_IMAGE_MENU_ITEM, PropImageMenuItemPrivate))
enum  {
	PROP_IMAGE_MENU_ITEM_DUMMY_PROPERTY
};
static void prop_image_menu_item_sync (PropImageMenuItem* self);
static void prop_image_menu_item_real_update_property (IPropItem* base, IBusProperty* property);
static void prop_image_menu_item_set_icon (PropImageMenuItem* self, const gchar* icon);
IconWidget* icon_widget_new (const gchar* icon_name_or_path, GtkIconSize size);
IconWidget* icon_widget_construct (GType object_type, const gchar* icon_name_or_path, GtkIconSize size);
GType icon_widget_get_type (void) G_GNUC_CONST;
static void prop_image_menu_item_real_activate (GtkMenuItem* base);
static void prop_image_menu_item_finalize (GObject* obj);
#define PROP_CHECK_MENU_ITEM_GET_PRIVATE(o) (G_TYPE_INSTANCE_GET_PRIVATE ((o), TYPE_PROP_CHECK_MENU_ITEM, PropCheckMenuItemPrivate))
enum  {
	PROP_CHECK_MENU_ITEM_DUMMY_PROPERTY
};
static void prop_check_menu_item_sync (PropCheckMenuItem* self);
static void prop_check_menu_item_real_update_property (IPropItem* base, IBusProperty* property);
static void prop_check_menu_item_real_toggled (GtkCheckMenuItem* base);
static void prop_check_menu_item_finalize (GObject* obj);
enum  {
	PROP_RADIO_MENU_ITEM_DUMMY_PROPERTY
};
#define PROP_SEPARATOR_MENU_ITEM_GET_PRIVATE(o) (G_TYPE_INSTANCE_GET_PRIVATE ((o), TYPE_PROP_SEPARATOR_MENU_ITEM, PropSeparatorMenuItemPrivate))
enum  {
	PROP_SEPARATOR_MENU_ITEM_DUMMY_PROPERTY
};
static void prop_separator_menu_item_real_update_property (IPropItem* base, IBusProperty* property);
static void prop_separator_menu_item_finalize (GObject* obj);


void property_manager_ProperyManager (PropertyManager* self) {
	g_return_if_fail (self != NULL);
}


static gpointer _g_object_ref0 (gpointer self) {
	return self ? g_object_ref (self) : NULL;
}


void property_manager_set_properties (PropertyManager* self, IBusPropList* props) {
	IBusPropList* _tmp0_;
	IBusPropList* _tmp1_;
	g_return_if_fail (self != NULL);
	g_return_if_fail (props != NULL);
	_tmp0_ = props;
	_tmp1_ = _g_object_ref0 (_tmp0_);
	_g_object_unref0 (self->priv->m_props);
	self->priv->m_props = _tmp1_;
}


gint property_manager_create_menu_items (PropertyManager* self, GtkMenu* menu) {
	gint result = 0;
	IBusPropList* _tmp0_;
	GtkMenu* _tmp1_;
	gint _tmp2_ = 0;
	g_return_val_if_fail (self != NULL, 0);
	g_return_val_if_fail (menu != NULL, 0);
	_tmp0_ = self->priv->m_props;
	_tmp1_ = menu;
	_tmp2_ = property_manager_create_menu_items_internal (self, _tmp0_, _tmp1_);
	result = _tmp2_;
	return result;
}


static void ____lambda16_ (PropertyManager* self, const gchar* k, gint s) {
	const gchar* _tmp0_;
	gint _tmp1_;
	g_return_if_fail (k != NULL);
	_tmp0_ = k;
	_tmp1_ = s;
	g_signal_emit_by_name (self, "property-activate", _tmp0_, _tmp1_);
}


static void _____lambda16__iprop_item_property_activate (IPropItem* _sender, const gchar* key, gint state, gpointer self) {
	____lambda16_ (self, key, state);
}


static gint property_manager_create_menu_items_internal (PropertyManager* self, IBusPropList* props, GtkMenu* menu) {
	gint result = 0;
	gint i;
	PropRadioMenuItem* last_radio;
	g_return_val_if_fail (self != NULL, 0);
	g_return_val_if_fail (props != NULL, 0);
	g_return_val_if_fail (menu != NULL, 0);
	i = 0;
	last_radio = NULL;
	while (TRUE) {
		IBusPropList* _tmp0_;
		gint _tmp1_;
		IBusProperty* _tmp2_ = NULL;
		IBusProperty* _tmp3_;
		IBusProperty* prop;
		IBusProperty* _tmp4_;
		IBusProperty* _tmp5_;
		const gchar* _tmp6_ = NULL;
		gint _tmp7_;
		IPropItem* item;
		IBusProperty* _tmp8_;
		IBusPropType _tmp9_ = 0;
		IBusProperty* _tmp36_;
		IBusPropType _tmp37_ = 0;
		IPropItem* _tmp38_;
		_tmp0_ = props;
		_tmp1_ = i;
		_tmp2_ = ibus_prop_list_get (_tmp0_, (guint) _tmp1_);
		_tmp3_ = _g_object_ref0 (_tmp2_);
		prop = _tmp3_;
		_tmp4_ = prop;
		if (_tmp4_ == NULL) {
			_g_object_unref0 (prop);
			break;
		}
		_tmp5_ = prop;
		_tmp6_ = ibus_property_get_key (_tmp5_);
		g_debug ("property.vala:44: ins prop = %s", _tmp6_);
		_tmp7_ = i;
		i = _tmp7_ + 1;
		item = NULL;
		_tmp8_ = prop;
		_tmp9_ = ibus_property_get_prop_type (_tmp8_);
		switch (_tmp9_) {
			case PROP_TYPE_NORMAL:
			{
				IBusProperty* _tmp10_;
				PropImageMenuItem* _tmp11_;
				_tmp10_ = prop;
				_tmp11_ = prop_image_menu_item_new (_tmp10_);
				g_object_ref_sink (_tmp11_);
				_g_object_unref0 (item);
				item = (IPropItem*) _tmp11_;
				break;
			}
			case PROP_TYPE_TOGGLE:
			{
				IBusProperty* _tmp12_;
				PropCheckMenuItem* _tmp13_;
				_tmp12_ = prop;
				_tmp13_ = prop_check_menu_item_new (_tmp12_);
				g_object_ref_sink (_tmp13_);
				_g_object_unref0 (item);
				item = (IPropItem*) _tmp13_;
				break;
			}
			case PROP_TYPE_RADIO:
			{
				{
					IBusProperty* _tmp14_;
					PropRadioMenuItem* _tmp15_;
					PropRadioMenuItem* _tmp16_;
					PropRadioMenuItem* radio;
					PropRadioMenuItem* _tmp17_;
					IPropItem* _tmp18_;
					PropRadioMenuItem* _tmp19_;
					PropRadioMenuItem* _tmp20_;
					_tmp14_ = prop;
					_tmp15_ = last_radio;
					_tmp16_ = prop_radio_menu_item_new (_tmp14_, _tmp15_);
					g_object_ref_sink (_tmp16_);
					radio = _tmp16_;
					_tmp17_ = radio;
					_tmp18_ = _g_object_ref0 ((IPropItem*) _tmp17_);
					_g_object_unref0 (item);
					item = _tmp18_;
					_tmp19_ = radio;
					_tmp20_ = _g_object_ref0 (_tmp19_);
					_g_object_unref0 (last_radio);
					last_radio = _tmp20_;
					_g_object_unref0 (radio);
				}
				break;
			}
			case PROP_TYPE_MENU:
			{
				{
					IBusProperty* _tmp21_;
					PropImageMenuItem* _tmp22_;
					PropImageMenuItem* menuitem;
					PropImageMenuItem* _tmp23_;
					IPropItem* _tmp24_;
					GtkMenu* _tmp25_;
					GtkMenu* submenu;
					IBusProperty* _tmp26_;
					IBusPropList* _tmp27_ = NULL;
					GtkMenu* _tmp28_;
					gint _tmp29_ = 0;
					_tmp21_ = prop;
					_tmp22_ = prop_image_menu_item_new (_tmp21_);
					g_object_ref_sink (_tmp22_);
					menuitem = _tmp22_;
					_tmp23_ = menuitem;
					_tmp24_ = _g_object_ref0 ((IPropItem*) _tmp23_);
					_g_object_unref0 (item);
					item = _tmp24_;
					_tmp25_ = (GtkMenu*) gtk_menu_new ();
					g_object_ref_sink (_tmp25_);
					submenu = _tmp25_;
					_tmp26_ = prop;
					_tmp27_ = ibus_property_get_sub_props (_tmp26_);
					_tmp28_ = submenu;
					_tmp29_ = property_manager_create_menu_items_internal (self, _tmp27_, _tmp28_);
					if (_tmp29_ > 0) {
						PropImageMenuItem* _tmp30_;
						GtkMenu* _tmp31_;
						_tmp30_ = menuitem;
						_tmp31_ = submenu;
						gtk_menu_item_set_submenu ((GtkMenuItem*) _tmp30_, (GtkWidget*) _tmp31_);
					}
					_g_object_unref0 (submenu);
					_g_object_unref0 (menuitem);
				}
				break;
			}
			case PROP_TYPE_SEPARATOR:
			{
				IBusProperty* _tmp32_;
				PropSeparatorMenuItem* _tmp33_;
				_tmp32_ = prop;
				_tmp33_ = prop_separator_menu_item_new (_tmp32_);
				g_object_ref_sink (_tmp33_);
				_g_object_unref0 (item);
				item = (IPropItem*) _tmp33_;
				break;
			}
			default:
			{
				IBusProperty* _tmp34_;
				IBusPropType _tmp35_ = 0;
				_tmp34_ = prop;
				_tmp35_ = ibus_property_get_prop_type (_tmp34_);
				g_warning ("property.vala:76: unknown property type %d", (gint) _tmp35_);
				break;
			}
		}
		_tmp36_ = prop;
		_tmp37_ = ibus_property_get_prop_type (_tmp36_);
		if (_tmp37_ != PROP_TYPE_RADIO) {
			_g_object_unref0 (last_radio);
			last_radio = NULL;
		}
		_tmp38_ = item;
		if (_tmp38_ != NULL) {
			GtkMenu* _tmp39_;
			IPropItem* _tmp40_;
			IPropItem* _tmp41_;
			_tmp39_ = menu;
			_tmp40_ = item;
			gtk_menu_shell_append ((GtkMenuShell*) _tmp39_, (GtkWidget*) (G_TYPE_CHECK_INSTANCE_TYPE (_tmp40_, GTK_TYPE_MENU_ITEM) ? ((GtkMenuItem*) _tmp40_) : NULL));
			_tmp41_ = item;
			g_signal_connect (_tmp41_, "property-activate", (GCallback) _____lambda16__iprop_item_property_activate, self);
		}
		_g_object_unref0 (item);
		_g_object_unref0 (prop);
	}
	result = i;
	_g_object_unref0 (last_radio);
	return result;
}


void property_manager_update_property (PropertyManager* self, IBusProperty* prop) {
	IBusProperty* _tmp0_;
	IBusPropList* _tmp1_;
	g_return_if_fail (self != NULL);
	g_return_if_fail (prop != NULL);
	_tmp0_ = prop;
	_vala_assert (_tmp0_ != NULL, "prop != null");
	_tmp1_ = self->priv->m_props;
	if (_tmp1_ != NULL) {
		IBusPropList* _tmp2_;
		IBusProperty* _tmp3_;
		_tmp2_ = self->priv->m_props;
		_tmp3_ = prop;
		ibus_prop_list_update_property (_tmp2_, _tmp3_);
	}
}


PropertyManager* property_manager_construct (GType object_type) {
	PropertyManager* self = NULL;
	self = (PropertyManager*) g_type_create_instance (object_type);
	return self;
}


PropertyManager* property_manager_new (void) {
	return property_manager_construct (TYPE_PROPERTY_MANAGER);
}


static void g_cclosure_user_marshal_VOID__STRING_INT (GClosure * closure, GValue * return_value, guint n_param_values, const GValue * param_values, gpointer invocation_hint, gpointer marshal_data) {
	typedef void (*GMarshalFunc_VOID__STRING_INT) (gpointer data1, const char* arg_1, gint arg_2, gpointer data2);
	register GMarshalFunc_VOID__STRING_INT callback;
	register GCClosure * cc;
	register gpointer data1;
	register gpointer data2;
	cc = (GCClosure *) closure;
	g_return_if_fail (n_param_values == 3);
	if (G_CCLOSURE_SWAP_DATA (closure)) {
		data1 = closure->data;
		data2 = param_values->data[0].v_pointer;
	} else {
		data1 = param_values->data[0].v_pointer;
		data2 = closure->data;
	}
	callback = (GMarshalFunc_VOID__STRING_INT) (marshal_data ? marshal_data : cc->callback);
	callback (data1, g_value_get_string (param_values + 1), g_value_get_int (param_values + 2), data2);
}


static void value_property_manager_init (GValue* value) {
	value->data[0].v_pointer = NULL;
}


static void value_property_manager_free_value (GValue* value) {
	if (value->data[0].v_pointer) {
		property_manager_unref (value->data[0].v_pointer);
	}
}


static void value_property_manager_copy_value (const GValue* src_value, GValue* dest_value) {
	if (src_value->data[0].v_pointer) {
		dest_value->data[0].v_pointer = property_manager_ref (src_value->data[0].v_pointer);
	} else {
		dest_value->data[0].v_pointer = NULL;
	}
}


static gpointer value_property_manager_peek_pointer (const GValue* value) {
	return value->data[0].v_pointer;
}


static gchar* value_property_manager_collect_value (GValue* value, guint n_collect_values, GTypeCValue* collect_values, guint collect_flags) {
	if (collect_values[0].v_pointer) {
		PropertyManager* object;
		object = collect_values[0].v_pointer;
		if (object->parent_instance.g_class == NULL) {
			return g_strconcat ("invalid unclassed object pointer for value type `", G_VALUE_TYPE_NAME (value), "'", NULL);
		} else if (!g_value_type_compatible (G_TYPE_FROM_INSTANCE (object), G_VALUE_TYPE (value))) {
			return g_strconcat ("invalid object type `", g_type_name (G_TYPE_FROM_INSTANCE (object)), "' for value type `", G_VALUE_TYPE_NAME (value), "'", NULL);
		}
		value->data[0].v_pointer = property_manager_ref (object);
	} else {
		value->data[0].v_pointer = NULL;
	}
	return NULL;
}


static gchar* value_property_manager_lcopy_value (const GValue* value, guint n_collect_values, GTypeCValue* collect_values, guint collect_flags) {
	PropertyManager** object_p;
	object_p = collect_values[0].v_pointer;
	if (!object_p) {
		return g_strdup_printf ("value location for `%s' passed as NULL", G_VALUE_TYPE_NAME (value));
	}
	if (!value->data[0].v_pointer) {
		*object_p = NULL;
	} else if (collect_flags & G_VALUE_NOCOPY_CONTENTS) {
		*object_p = value->data[0].v_pointer;
	} else {
		*object_p = property_manager_ref (value->data[0].v_pointer);
	}
	return NULL;
}


GParamSpec* param_spec_property_manager (const gchar* name, const gchar* nick, const gchar* blurb, GType object_type, GParamFlags flags) {
	ParamSpecPropertyManager* spec;
	g_return_val_if_fail (g_type_is_a (object_type, TYPE_PROPERTY_MANAGER), NULL);
	spec = g_param_spec_internal (G_TYPE_PARAM_OBJECT, name, nick, blurb, flags);
	G_PARAM_SPEC (spec)->value_type = object_type;
	return G_PARAM_SPEC (spec);
}


gpointer value_get_property_manager (const GValue* value) {
	g_return_val_if_fail (G_TYPE_CHECK_VALUE_TYPE (value, TYPE_PROPERTY_MANAGER), NULL);
	return value->data[0].v_pointer;
}


void value_set_property_manager (GValue* value, gpointer v_object) {
	PropertyManager* old;
	g_return_if_fail (G_TYPE_CHECK_VALUE_TYPE (value, TYPE_PROPERTY_MANAGER));
	old = value->data[0].v_pointer;
	if (v_object) {
		g_return_if_fail (G_TYPE_CHECK_INSTANCE_TYPE (v_object, TYPE_PROPERTY_MANAGER));
		g_return_if_fail (g_value_type_compatible (G_TYPE_FROM_INSTANCE (v_object), G_VALUE_TYPE (value)));
		value->data[0].v_pointer = v_object;
		property_manager_ref (value->data[0].v_pointer);
	} else {
		value->data[0].v_pointer = NULL;
	}
	if (old) {
		property_manager_unref (old);
	}
}


void value_take_property_manager (GValue* value, gpointer v_object) {
	PropertyManager* old;
	g_return_if_fail (G_TYPE_CHECK_VALUE_TYPE (value, TYPE_PROPERTY_MANAGER));
	old = value->data[0].v_pointer;
	if (v_object) {
		g_return_if_fail (G_TYPE_CHECK_INSTANCE_TYPE (v_object, TYPE_PROPERTY_MANAGER));
		g_return_if_fail (g_value_type_compatible (G_TYPE_FROM_INSTANCE (v_object), G_VALUE_TYPE (value)));
		value->data[0].v_pointer = v_object;
	} else {
		value->data[0].v_pointer = NULL;
	}
	if (old) {
		property_manager_unref (old);
	}
}


static void property_manager_class_init (PropertyManagerClass * klass) {
	property_manager_parent_class = g_type_class_peek_parent (klass);
	PROPERTY_MANAGER_CLASS (klass)->finalize = property_manager_finalize;
	g_type_class_add_private (klass, sizeof (PropertyManagerPrivate));
	g_signal_new ("property_activate", TYPE_PROPERTY_MANAGER, G_SIGNAL_RUN_LAST, 0, NULL, NULL, g_cclosure_user_marshal_VOID__STRING_INT, G_TYPE_NONE, 2, G_TYPE_STRING, G_TYPE_INT);
}


static void property_manager_instance_init (PropertyManager * self) {
	self->priv = PROPERTY_MANAGER_GET_PRIVATE (self);
	self->ref_count = 1;
}


static void property_manager_finalize (PropertyManager* obj) {
	PropertyManager * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (obj, TYPE_PROPERTY_MANAGER, PropertyManager);
	_g_object_unref0 (self->priv->m_props);
}


GType property_manager_get_type (void) {
	static volatile gsize property_manager_type_id__volatile = 0;
	if (g_once_init_enter (&property_manager_type_id__volatile)) {
		static const GTypeValueTable g_define_type_value_table = { value_property_manager_init, value_property_manager_free_value, value_property_manager_copy_value, value_property_manager_peek_pointer, "p", value_property_manager_collect_value, "p", value_property_manager_lcopy_value };
		static const GTypeInfo g_define_type_info = { sizeof (PropertyManagerClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) property_manager_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (PropertyManager), 0, (GInstanceInitFunc) property_manager_instance_init, &g_define_type_value_table };
		static const GTypeFundamentalInfo g_define_type_fundamental_info = { (G_TYPE_FLAG_CLASSED | G_TYPE_FLAG_INSTANTIATABLE | G_TYPE_FLAG_DERIVABLE | G_TYPE_FLAG_DEEP_DERIVABLE) };
		GType property_manager_type_id;
		property_manager_type_id = g_type_register_fundamental (g_type_fundamental_next (), "PropertyManager", &g_define_type_info, &g_define_type_fundamental_info, 0);
		g_once_init_leave (&property_manager_type_id__volatile, property_manager_type_id);
	}
	return property_manager_type_id__volatile;
}


gpointer property_manager_ref (gpointer instance) {
	PropertyManager* self;
	self = instance;
	g_atomic_int_inc (&self->ref_count);
	return instance;
}


void property_manager_unref (gpointer instance) {
	PropertyManager* self;
	self = instance;
	if (g_atomic_int_dec_and_test (&self->ref_count)) {
		PROPERTY_MANAGER_GET_CLASS (self)->finalize (self);
		g_type_free_instance ((GTypeInstance *) self);
	}
}


void iprop_item_update_property (IPropItem* self, IBusProperty* prop) {
	g_return_if_fail (self != NULL);
	IPROP_ITEM_GET_INTERFACE (self)->update_property (self, prop);
}


static void iprop_item_base_init (IPropItemIface * iface) {
	static gboolean initialized = FALSE;
	if (!initialized) {
		initialized = TRUE;
		g_signal_new ("property_activate", TYPE_IPROP_ITEM, G_SIGNAL_RUN_LAST, 0, NULL, NULL, g_cclosure_user_marshal_VOID__STRING_INT, G_TYPE_NONE, 2, G_TYPE_STRING, G_TYPE_INT);
	}
}


GType iprop_item_get_type (void) {
	static volatile gsize iprop_item_type_id__volatile = 0;
	if (g_once_init_enter (&iprop_item_type_id__volatile)) {
		static const GTypeInfo g_define_type_info = { sizeof (IPropItemIface), (GBaseInitFunc) iprop_item_base_init, (GBaseFinalizeFunc) NULL, (GClassInitFunc) NULL, (GClassFinalizeFunc) NULL, NULL, 0, 0, (GInstanceInitFunc) NULL, NULL };
		GType iprop_item_type_id;
		iprop_item_type_id = g_type_register_static (G_TYPE_INTERFACE, "IPropItem", &g_define_type_info, 0);
		g_type_interface_add_prerequisite (iprop_item_type_id, G_TYPE_OBJECT);
		g_once_init_leave (&iprop_item_type_id__volatile, iprop_item_type_id);
	}
	return iprop_item_type_id__volatile;
}


PropImageMenuItem* prop_image_menu_item_construct (GType object_type, IBusProperty* property) {
	PropImageMenuItem * self = NULL;
	IBusProperty* _tmp0_;
	IBusProperty* _tmp1_;
	IBusProperty* _tmp2_;
	g_return_val_if_fail (property != NULL, NULL);
	self = (PropImageMenuItem*) g_object_new (object_type, NULL);
	_tmp0_ = property;
	_vala_assert (_tmp0_ != NULL, "property != null");
	_tmp1_ = property;
	_tmp2_ = _g_object_ref0 (_tmp1_);
	_g_object_unref0 (self->priv->m_property);
	self->priv->m_property = _tmp2_;
	gtk_widget_set_no_show_all ((GtkWidget*) self, TRUE);
	prop_image_menu_item_sync (self);
	return self;
}


PropImageMenuItem* prop_image_menu_item_new (IBusProperty* property) {
	return prop_image_menu_item_construct (TYPE_PROP_IMAGE_MENU_ITEM, property);
}


static void prop_image_menu_item_real_update_property (IPropItem* base, IBusProperty* property) {
	PropImageMenuItem * self;
	IBusProperty* _tmp0_;
	IBusProperty* _tmp1_;
	IBusText* _tmp2_ = NULL;
	IBusProperty* _tmp3_;
	IBusProperty* _tmp4_;
	const gchar* _tmp5_ = NULL;
	IBusProperty* _tmp6_;
	IBusProperty* _tmp7_;
	gboolean _tmp8_ = FALSE;
	IBusProperty* _tmp9_;
	IBusProperty* _tmp10_;
	gboolean _tmp11_ = FALSE;
	IBusProperty* _tmp12_;
	IBusProperty* _tmp13_;
	IBusText* _tmp14_ = NULL;
	IBusProperty* _tmp15_;
	IBusProperty* _tmp16_;
	IBusPropState _tmp17_ = 0;
	self = (PropImageMenuItem*) base;
	g_return_if_fail (property != NULL);
	_tmp0_ = self->priv->m_property;
	_tmp1_ = property;
	_tmp2_ = ibus_property_get_label (_tmp1_);
	ibus_property_set_label (_tmp0_, _tmp2_);
	_tmp3_ = self->priv->m_property;
	_tmp4_ = property;
	_tmp5_ = ibus_property_get_icon (_tmp4_);
	ibus_property_set_icon (_tmp3_, _tmp5_);
	_tmp6_ = self->priv->m_property;
	_tmp7_ = property;
	_tmp8_ = ibus_property_get_visible (_tmp7_);
	ibus_property_set_visible (_tmp6_, _tmp8_);
	_tmp9_ = self->priv->m_property;
	_tmp10_ = property;
	_tmp11_ = ibus_property_get_sensitive (_tmp10_);
	ibus_property_set_sensitive (_tmp9_, _tmp11_);
	_tmp12_ = self->priv->m_property;
	_tmp13_ = property;
	_tmp14_ = ibus_property_get_tooltip (_tmp13_);
	ibus_property_set_tooltip (_tmp12_, _tmp14_);
	_tmp15_ = self->priv->m_property;
	_tmp16_ = property;
	_tmp17_ = ibus_property_get_state (_tmp16_);
	ibus_property_set_state (_tmp15_, _tmp17_);
	prop_image_menu_item_sync (self);
}


static void prop_image_menu_item_sync (PropImageMenuItem* self) {
	IBusProperty* _tmp0_;
	IBusText* _tmp1_ = NULL;
	const gchar* _tmp2_ = NULL;
	IBusProperty* _tmp3_;
	const gchar* _tmp4_ = NULL;
	IBusProperty* _tmp7_;
	gboolean _tmp8_ = FALSE;
	IBusProperty* _tmp9_;
	gboolean _tmp10_ = FALSE;
	g_return_if_fail (self != NULL);
	_tmp0_ = self->priv->m_property;
	_tmp1_ = ibus_property_get_label (_tmp0_);
	_tmp2_ = ibus_text_get_text (_tmp1_);
	gtk_menu_item_set_label ((GtkMenuItem*) self, _tmp2_);
	_tmp3_ = self->priv->m_property;
	_tmp4_ = ibus_property_get_icon (_tmp3_);
	if (g_strcmp0 (_tmp4_, "") != 0) {
		IBusProperty* _tmp5_;
		const gchar* _tmp6_ = NULL;
		_tmp5_ = self->priv->m_property;
		_tmp6_ = ibus_property_get_icon (_tmp5_);
		prop_image_menu_item_set_icon (self, _tmp6_);
	}
	_tmp7_ = self->priv->m_property;
	_tmp8_ = ibus_property_get_visible (_tmp7_);
	gtk_widget_set_visible ((GtkWidget*) self, _tmp8_);
	_tmp9_ = self->priv->m_property;
	_tmp10_ = ibus_property_get_sensitive (_tmp9_);
	gtk_widget_set_sensitive ((GtkWidget*) self, _tmp10_);
}


static void prop_image_menu_item_set_icon (PropImageMenuItem* self, const gchar* icon) {
	const gchar* _tmp0_;
	IconWidget* _tmp1_;
	IconWidget* _tmp2_;
	g_return_if_fail (self != NULL);
	g_return_if_fail (icon != NULL);
	_tmp0_ = icon;
	_tmp1_ = icon_widget_new (_tmp0_, GTK_ICON_SIZE_MENU);
	g_object_ref_sink (_tmp1_);
	_tmp2_ = _tmp1_;
	gtk_image_menu_item_set_image ((GtkImageMenuItem*) self, (GtkWidget*) _tmp2_);
	_g_object_unref0 (_tmp2_);
}


static void prop_image_menu_item_real_activate (GtkMenuItem* base) {
	PropImageMenuItem * self;
	IBusProperty* _tmp0_;
	const gchar* _tmp1_ = NULL;
	IBusProperty* _tmp2_;
	IBusPropState _tmp3_ = 0;
	self = (PropImageMenuItem*) base;
	_tmp0_ = self->priv->m_property;
	_tmp1_ = ibus_property_get_key (_tmp0_);
	_tmp2_ = self->priv->m_property;
	_tmp3_ = ibus_property_get_state (_tmp2_);
	g_signal_emit_by_name ((IPropItem*) self, "property-activate", _tmp1_, (gint) _tmp3_);
}


static void prop_image_menu_item_class_init (PropImageMenuItemClass * klass) {
	prop_image_menu_item_parent_class = g_type_class_peek_parent (klass);
	g_type_class_add_private (klass, sizeof (PropImageMenuItemPrivate));
	GTK_MENU_ITEM_CLASS (klass)->activate = prop_image_menu_item_real_activate;
	G_OBJECT_CLASS (klass)->finalize = prop_image_menu_item_finalize;
}


static void prop_image_menu_item_iprop_item_interface_init (IPropItemIface * iface) {
	prop_image_menu_item_iprop_item_parent_iface = g_type_interface_peek_parent (iface);
	iface->update_property = (void (*)(IPropItem*, IBusProperty*)) prop_image_menu_item_real_update_property;
}


static void prop_image_menu_item_instance_init (PropImageMenuItem * self) {
	self->priv = PROP_IMAGE_MENU_ITEM_GET_PRIVATE (self);
}


static void prop_image_menu_item_finalize (GObject* obj) {
	PropImageMenuItem * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (obj, TYPE_PROP_IMAGE_MENU_ITEM, PropImageMenuItem);
	_g_object_unref0 (self->priv->m_property);
	G_OBJECT_CLASS (prop_image_menu_item_parent_class)->finalize (obj);
}


GType prop_image_menu_item_get_type (void) {
	static volatile gsize prop_image_menu_item_type_id__volatile = 0;
	if (g_once_init_enter (&prop_image_menu_item_type_id__volatile)) {
		static const GTypeInfo g_define_type_info = { sizeof (PropImageMenuItemClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) prop_image_menu_item_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (PropImageMenuItem), 0, (GInstanceInitFunc) prop_image_menu_item_instance_init, NULL };
		static const GInterfaceInfo iprop_item_info = { (GInterfaceInitFunc) prop_image_menu_item_iprop_item_interface_init, (GInterfaceFinalizeFunc) NULL, NULL};
		GType prop_image_menu_item_type_id;
		prop_image_menu_item_type_id = g_type_register_static (GTK_TYPE_IMAGE_MENU_ITEM, "PropImageMenuItem", &g_define_type_info, 0);
		g_type_add_interface_static (prop_image_menu_item_type_id, TYPE_IPROP_ITEM, &iprop_item_info);
		g_once_init_leave (&prop_image_menu_item_type_id__volatile, prop_image_menu_item_type_id);
	}
	return prop_image_menu_item_type_id__volatile;
}


PropCheckMenuItem* prop_check_menu_item_construct (GType object_type, IBusProperty* property) {
	PropCheckMenuItem * self = NULL;
	IBusProperty* _tmp0_;
	IBusProperty* _tmp1_;
	IBusProperty* _tmp2_;
	g_return_val_if_fail (property != NULL, NULL);
	self = (PropCheckMenuItem*) g_object_new (object_type, NULL);
	_tmp0_ = property;
	_vala_assert (_tmp0_ != NULL, "property != null");
	_tmp1_ = property;
	_tmp2_ = _g_object_ref0 (_tmp1_);
	_g_object_unref0 (self->priv->m_property);
	self->priv->m_property = _tmp2_;
	gtk_widget_set_no_show_all ((GtkWidget*) self, TRUE);
	prop_check_menu_item_sync (self);
	return self;
}


PropCheckMenuItem* prop_check_menu_item_new (IBusProperty* property) {
	return prop_check_menu_item_construct (TYPE_PROP_CHECK_MENU_ITEM, property);
}


static void prop_check_menu_item_real_update_property (IPropItem* base, IBusProperty* property) {
	PropCheckMenuItem * self;
	IBusProperty* _tmp0_;
	IBusProperty* _tmp1_;
	IBusText* _tmp2_ = NULL;
	IBusProperty* _tmp3_;
	IBusProperty* _tmp4_;
	const gchar* _tmp5_ = NULL;
	IBusProperty* _tmp6_;
	IBusProperty* _tmp7_;
	gboolean _tmp8_ = FALSE;
	IBusProperty* _tmp9_;
	IBusProperty* _tmp10_;
	gboolean _tmp11_ = FALSE;
	IBusProperty* _tmp12_;
	IBusProperty* _tmp13_;
	IBusText* _tmp14_ = NULL;
	IBusProperty* _tmp15_;
	IBusProperty* _tmp16_;
	IBusPropState _tmp17_ = 0;
	self = (PropCheckMenuItem*) base;
	g_return_if_fail (property != NULL);
	_tmp0_ = self->priv->m_property;
	_tmp1_ = property;
	_tmp2_ = ibus_property_get_label (_tmp1_);
	ibus_property_set_label (_tmp0_, _tmp2_);
	_tmp3_ = self->priv->m_property;
	_tmp4_ = property;
	_tmp5_ = ibus_property_get_icon (_tmp4_);
	ibus_property_set_icon (_tmp3_, _tmp5_);
	_tmp6_ = self->priv->m_property;
	_tmp7_ = property;
	_tmp8_ = ibus_property_get_visible (_tmp7_);
	ibus_property_set_visible (_tmp6_, _tmp8_);
	_tmp9_ = self->priv->m_property;
	_tmp10_ = property;
	_tmp11_ = ibus_property_get_sensitive (_tmp10_);
	ibus_property_set_sensitive (_tmp9_, _tmp11_);
	_tmp12_ = self->priv->m_property;
	_tmp13_ = property;
	_tmp14_ = ibus_property_get_tooltip (_tmp13_);
	ibus_property_set_tooltip (_tmp12_, _tmp14_);
	_tmp15_ = self->priv->m_property;
	_tmp16_ = property;
	_tmp17_ = ibus_property_get_state (_tmp16_);
	ibus_property_set_state (_tmp15_, _tmp17_);
	prop_check_menu_item_sync (self);
}


static void prop_check_menu_item_sync (PropCheckMenuItem* self) {
	IBusProperty* _tmp0_;
	IBusText* _tmp1_ = NULL;
	const gchar* _tmp2_ = NULL;
	IBusProperty* _tmp3_;
	gboolean _tmp4_ = FALSE;
	IBusProperty* _tmp5_;
	gboolean _tmp6_ = FALSE;
	IBusProperty* _tmp7_;
	IBusPropState _tmp8_ = 0;
	g_return_if_fail (self != NULL);
	_tmp0_ = self->priv->m_property;
	_tmp1_ = ibus_property_get_label (_tmp0_);
	_tmp2_ = ibus_text_get_text (_tmp1_);
	gtk_menu_item_set_label ((GtkMenuItem*) self, _tmp2_);
	_tmp3_ = self->priv->m_property;
	_tmp4_ = ibus_property_get_visible (_tmp3_);
	gtk_widget_set_visible ((GtkWidget*) self, _tmp4_);
	_tmp5_ = self->priv->m_property;
	_tmp6_ = ibus_property_get_sensitive (_tmp5_);
	gtk_widget_set_sensitive ((GtkWidget*) self, _tmp6_);
	_tmp7_ = self->priv->m_property;
	_tmp8_ = ibus_property_get_state (_tmp7_);
	gtk_check_menu_item_set_active ((GtkCheckMenuItem*) self, _tmp8_ == PROP_STATE_CHECKED);
}


static void prop_check_menu_item_real_toggled (GtkCheckMenuItem* base) {
	PropCheckMenuItem * self;
	IBusPropState _tmp0_ = 0;
	gboolean _tmp1_ = FALSE;
	IBusPropState _tmp2_;
	IBusPropState new_state;
	IBusProperty* _tmp3_;
	IBusPropState _tmp4_ = 0;
	IBusPropState _tmp5_;
	self = (PropCheckMenuItem*) base;
	_tmp1_ = gtk_check_menu_item_get_active ((GtkCheckMenuItem*) self);
	if (_tmp1_) {
		_tmp0_ = PROP_STATE_CHECKED;
	} else {
		_tmp0_ = PROP_STATE_UNCHECKED;
	}
	_tmp2_ = _tmp0_;
	new_state = _tmp2_;
	_tmp3_ = self->priv->m_property;
	_tmp4_ = ibus_property_get_state (_tmp3_);
	_tmp5_ = new_state;
	if (_tmp4_ != _tmp5_) {
		IBusProperty* _tmp6_;
		IBusPropState _tmp7_;
		IBusProperty* _tmp8_;
		const gchar* _tmp9_ = NULL;
		IBusProperty* _tmp10_;
		IBusPropState _tmp11_ = 0;
		_tmp6_ = self->priv->m_property;
		_tmp7_ = new_state;
		ibus_property_set_state (_tmp6_, _tmp7_);
		_tmp8_ = self->priv->m_property;
		_tmp9_ = ibus_property_get_key (_tmp8_);
		_tmp10_ = self->priv->m_property;
		_tmp11_ = ibus_property_get_state (_tmp10_);
		g_signal_emit_by_name ((IPropItem*) self, "property-activate", _tmp9_, (gint) _tmp11_);
	}
}


static void prop_check_menu_item_class_init (PropCheckMenuItemClass * klass) {
	prop_check_menu_item_parent_class = g_type_class_peek_parent (klass);
	g_type_class_add_private (klass, sizeof (PropCheckMenuItemPrivate));
	GTK_CHECK_MENU_ITEM_CLASS (klass)->toggled = prop_check_menu_item_real_toggled;
	G_OBJECT_CLASS (klass)->finalize = prop_check_menu_item_finalize;
}


static void prop_check_menu_item_iprop_item_interface_init (IPropItemIface * iface) {
	prop_check_menu_item_iprop_item_parent_iface = g_type_interface_peek_parent (iface);
	iface->update_property = (void (*)(IPropItem*, IBusProperty*)) prop_check_menu_item_real_update_property;
}


static void prop_check_menu_item_instance_init (PropCheckMenuItem * self) {
	self->priv = PROP_CHECK_MENU_ITEM_GET_PRIVATE (self);
}


static void prop_check_menu_item_finalize (GObject* obj) {
	PropCheckMenuItem * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (obj, TYPE_PROP_CHECK_MENU_ITEM, PropCheckMenuItem);
	_g_object_unref0 (self->priv->m_property);
	G_OBJECT_CLASS (prop_check_menu_item_parent_class)->finalize (obj);
}


GType prop_check_menu_item_get_type (void) {
	static volatile gsize prop_check_menu_item_type_id__volatile = 0;
	if (g_once_init_enter (&prop_check_menu_item_type_id__volatile)) {
		static const GTypeInfo g_define_type_info = { sizeof (PropCheckMenuItemClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) prop_check_menu_item_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (PropCheckMenuItem), 0, (GInstanceInitFunc) prop_check_menu_item_instance_init, NULL };
		static const GInterfaceInfo iprop_item_info = { (GInterfaceInitFunc) prop_check_menu_item_iprop_item_interface_init, (GInterfaceFinalizeFunc) NULL, NULL};
		GType prop_check_menu_item_type_id;
		prop_check_menu_item_type_id = g_type_register_static (GTK_TYPE_RADIO_MENU_ITEM, "PropCheckMenuItem", &g_define_type_info, 0);
		g_type_add_interface_static (prop_check_menu_item_type_id, TYPE_IPROP_ITEM, &iprop_item_info);
		g_once_init_leave (&prop_check_menu_item_type_id__volatile, prop_check_menu_item_type_id);
	}
	return prop_check_menu_item_type_id__volatile;
}


PropRadioMenuItem* prop_radio_menu_item_construct (GType object_type, IBusProperty* property, PropRadioMenuItem* group_source) {
	PropRadioMenuItem * self = NULL;
	IBusProperty* _tmp0_;
	PropRadioMenuItem* _tmp1_;
	g_return_val_if_fail (property != NULL, NULL);
	_tmp0_ = property;
	self = (PropRadioMenuItem*) prop_check_menu_item_construct (object_type, _tmp0_);
	_tmp1_ = group_source;
	if (_tmp1_ != NULL) {
		PropRadioMenuItem* _tmp2_;
		GSList* _tmp3_ = NULL;
		_tmp2_ = group_source;
		_tmp3_ = gtk_radio_menu_item_get_group ((GtkRadioMenuItem*) _tmp2_);
		gtk_radio_menu_item_set_group ((GtkRadioMenuItem*) self, _tmp3_);
	}
	return self;
}


PropRadioMenuItem* prop_radio_menu_item_new (IBusProperty* property, PropRadioMenuItem* group_source) {
	return prop_radio_menu_item_construct (TYPE_PROP_RADIO_MENU_ITEM, property, group_source);
}


static void prop_radio_menu_item_class_init (PropRadioMenuItemClass * klass) {
	prop_radio_menu_item_parent_class = g_type_class_peek_parent (klass);
}


static void prop_radio_menu_item_instance_init (PropRadioMenuItem * self) {
}


GType prop_radio_menu_item_get_type (void) {
	static volatile gsize prop_radio_menu_item_type_id__volatile = 0;
	if (g_once_init_enter (&prop_radio_menu_item_type_id__volatile)) {
		static const GTypeInfo g_define_type_info = { sizeof (PropRadioMenuItemClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) prop_radio_menu_item_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (PropRadioMenuItem), 0, (GInstanceInitFunc) prop_radio_menu_item_instance_init, NULL };
		GType prop_radio_menu_item_type_id;
		prop_radio_menu_item_type_id = g_type_register_static (TYPE_PROP_CHECK_MENU_ITEM, "PropRadioMenuItem", &g_define_type_info, 0);
		g_once_init_leave (&prop_radio_menu_item_type_id__volatile, prop_radio_menu_item_type_id);
	}
	return prop_radio_menu_item_type_id__volatile;
}


PropSeparatorMenuItem* prop_separator_menu_item_construct (GType object_type, IBusProperty* property) {
	PropSeparatorMenuItem * self = NULL;
	IBusProperty* _tmp0_;
	IBusProperty* _tmp1_;
	IBusProperty* _tmp2_;
	g_return_val_if_fail (property != NULL, NULL);
	self = (PropSeparatorMenuItem*) g_object_new (object_type, NULL);
	_tmp0_ = property;
	_vala_assert (_tmp0_ != NULL, "property != null");
	_tmp1_ = property;
	_tmp2_ = _g_object_ref0 (_tmp1_);
	_g_object_unref0 (self->priv->m_property);
	self->priv->m_property = _tmp2_;
	return self;
}


PropSeparatorMenuItem* prop_separator_menu_item_new (IBusProperty* property) {
	return prop_separator_menu_item_construct (TYPE_PROP_SEPARATOR_MENU_ITEM, property);
}


static void prop_separator_menu_item_real_update_property (IPropItem* base, IBusProperty* property) {
	PropSeparatorMenuItem * self;
	self = (PropSeparatorMenuItem*) base;
	g_return_if_fail (property != NULL);
}


static void prop_separator_menu_item_class_init (PropSeparatorMenuItemClass * klass) {
	prop_separator_menu_item_parent_class = g_type_class_peek_parent (klass);
	g_type_class_add_private (klass, sizeof (PropSeparatorMenuItemPrivate));
	G_OBJECT_CLASS (klass)->finalize = prop_separator_menu_item_finalize;
}


static void prop_separator_menu_item_iprop_item_interface_init (IPropItemIface * iface) {
	prop_separator_menu_item_iprop_item_parent_iface = g_type_interface_peek_parent (iface);
	iface->update_property = (void (*)(IPropItem*, IBusProperty*)) prop_separator_menu_item_real_update_property;
}


static void prop_separator_menu_item_instance_init (PropSeparatorMenuItem * self) {
	self->priv = PROP_SEPARATOR_MENU_ITEM_GET_PRIVATE (self);
}


static void prop_separator_menu_item_finalize (GObject* obj) {
	PropSeparatorMenuItem * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (obj, TYPE_PROP_SEPARATOR_MENU_ITEM, PropSeparatorMenuItem);
	_g_object_unref0 (self->priv->m_property);
	G_OBJECT_CLASS (prop_separator_menu_item_parent_class)->finalize (obj);
}


GType prop_separator_menu_item_get_type (void) {
	static volatile gsize prop_separator_menu_item_type_id__volatile = 0;
	if (g_once_init_enter (&prop_separator_menu_item_type_id__volatile)) {
		static const GTypeInfo g_define_type_info = { sizeof (PropSeparatorMenuItemClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) prop_separator_menu_item_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (PropSeparatorMenuItem), 0, (GInstanceInitFunc) prop_separator_menu_item_instance_init, NULL };
		static const GInterfaceInfo iprop_item_info = { (GInterfaceInitFunc) prop_separator_menu_item_iprop_item_interface_init, (GInterfaceFinalizeFunc) NULL, NULL};
		GType prop_separator_menu_item_type_id;
		prop_separator_menu_item_type_id = g_type_register_static (GTK_TYPE_SEPARATOR_MENU_ITEM, "PropSeparatorMenuItem", &g_define_type_info, 0);
		g_type_add_interface_static (prop_separator_menu_item_type_id, TYPE_IPROP_ITEM, &iprop_item_info);
		g_once_init_leave (&prop_separator_menu_item_type_id__volatile, prop_separator_menu_item_type_id);
	}
	return prop_separator_menu_item_type_id__volatile;
}



