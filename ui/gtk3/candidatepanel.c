/* candidatepanel.c generated by valac 0.20.1, the Vala compiler
 * generated from candidatepanel.vala, do not modify */

/* vim:set et sts=4 sw=4:
 *
 * ibus - The Input Bus
 *
 * Copyright(c) 2011 Peng Huang <shawn.p.huang@gmail.com>
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2.1 of the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301
 * USA
 */

#include <glib.h>
#include <glib-object.h>
#include <gtk/gtk.h>
#include <gdk/gdk.h>
#include <ibus.h>
#include <string.h>
#include <cairo.h>


#define TYPE_CANDIDATE_PANEL (candidate_panel_get_type ())
#define CANDIDATE_PANEL(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_CANDIDATE_PANEL, CandidatePanel))
#define CANDIDATE_PANEL_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_CANDIDATE_PANEL, CandidatePanelClass))
#define IS_CANDIDATE_PANEL(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_CANDIDATE_PANEL))
#define IS_CANDIDATE_PANEL_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_CANDIDATE_PANEL))
#define CANDIDATE_PANEL_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_CANDIDATE_PANEL, CandidatePanelClass))

typedef struct _CandidatePanel CandidatePanel;
typedef struct _CandidatePanelClass CandidatePanelClass;
typedef struct _CandidatePanelPrivate CandidatePanelPrivate;

#define TYPE_CANDIDATE_AREA (candidate_area_get_type ())
#define CANDIDATE_AREA(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_CANDIDATE_AREA, CandidateArea))
#define CANDIDATE_AREA_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_CANDIDATE_AREA, CandidateAreaClass))
#define IS_CANDIDATE_AREA(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_CANDIDATE_AREA))
#define IS_CANDIDATE_AREA_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_CANDIDATE_AREA))
#define CANDIDATE_AREA_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_CANDIDATE_AREA, CandidateAreaClass))

typedef struct _CandidateArea CandidateArea;
typedef struct _CandidateAreaClass CandidateAreaClass;

#define TYPE_HSEPARATOR (hseparator_get_type ())
#define HSEPARATOR(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_HSEPARATOR, HSeparator))
#define HSEPARATOR_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_HSEPARATOR, HSeparatorClass))
#define IS_HSEPARATOR(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_HSEPARATOR))
#define IS_HSEPARATOR_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_HSEPARATOR))
#define HSEPARATOR_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_HSEPARATOR, HSeparatorClass))

typedef struct _HSeparator HSeparator;
typedef struct _HSeparatorClass HSeparatorClass;
#define _g_object_unref0(var) ((var == NULL) ? NULL : (var = (g_object_unref (var), NULL)))

#define TYPE_HANDLE (handle_get_type ())
#define HANDLE(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_HANDLE, Handle))
#define HANDLE_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_HANDLE, HandleClass))
#define IS_HANDLE(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_HANDLE))
#define IS_HANDLE_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_HANDLE))
#define HANDLE_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_HANDLE, HandleClass))

typedef struct _Handle Handle;
typedef struct _HandleClass HandleClass;

struct _CandidatePanel {
	GtkHBox parent_instance;
	CandidatePanelPrivate * priv;
};

struct _CandidatePanelClass {
	GtkHBoxClass parent_class;
};

struct _CandidatePanelPrivate {
	gboolean m_vertical;
	GtkWindow* m_toplevel;
	GtkBox* m_vbox;
	GtkLabel* m_preedit_label;
	GtkLabel* m_aux_label;
	CandidateArea* m_candidate_area;
	HSeparator* m_hseparator;
	GdkRectangle m_cursor_location;
};


static gpointer candidate_panel_parent_class = NULL;

GType candidate_panel_get_type (void) G_GNUC_CONST;
GType candidate_area_get_type (void) G_GNUC_CONST;
GType hseparator_get_type (void) G_GNUC_CONST;
#define CANDIDATE_PANEL_GET_PRIVATE(o) (G_TYPE_INSTANCE_GET_PRIVATE ((o), TYPE_CANDIDATE_PANEL, CandidatePanelPrivate))
enum  {
	CANDIDATE_PANEL_DUMMY_PROPERTY
};
CandidatePanel* candidate_panel_new (void);
CandidatePanel* candidate_panel_construct (GType object_type);
static gboolean __lambda7_ (CandidatePanel* self, GtkWidget* w, GdkEventButton* e);
void candidate_panel_set_vertical (CandidatePanel* self, gboolean vertical);
static gboolean ___lambda7__gtk_widget_button_press_event (GtkWidget* _sender, GdkEventButton* event, gpointer self);
Handle* handle_new (void);
Handle* handle_construct (GType object_type);
GType handle_get_type (void) G_GNUC_CONST;
static void candidate_panel_create_ui (CandidatePanel* self);
void candidate_area_set_vertical (CandidateArea* self, gboolean vertical, gboolean force);
static void candidate_panel_set_orientation (CandidatePanel* self, IBusOrientation orientation);
void candidate_panel_set_cursor_location (CandidatePanel* self, gint x, gint y, gint width, gint height);
static gboolean _cairo_rectangle_int_equal (const cairo_rectangle_int_t* s1, const cairo_rectangle_int_t* s2);
static void candidate_panel_adjust_window_position (CandidatePanel* self);
static void candidate_panel_set_labels (CandidatePanel* self, IBusText** labels, int labels_length1);
void candidate_area_set_labels (CandidateArea* self, IBusText** labels, int labels_length1);
void candidate_panel_set_preedit_text (CandidatePanel* self, IBusText* text, guint cursor);
static void candidate_panel_update (CandidatePanel* self);
void candidate_panel_set_auxiliary_text (CandidatePanel* self, IBusText* text);
void candidate_panel_set_lookup_table (CandidatePanel* self, IBusLookupTable* table);
static void _vala_array_add8 (IBusText*** array, int* length, int* size, IBusText* value);
static void _vala_array_add9 (IBusText*** array, int* length, int* size, IBusText* value);
void candidate_area_set_candidates (CandidateArea* self, IBusText** candidates, int candidates_length1, guint focus_candidate, gboolean show_cursor);
static void candidate_panel_real_get_preferred_width (GtkWidget* base, gint* minimum_width, gint* natural_width);
static void candidate_panel_real_get_preferred_height (GtkWidget* base, gint* minimum_width, gint* natural_width);
CandidateArea* candidate_area_new (gboolean vertical);
CandidateArea* candidate_area_construct (GType object_type, gboolean vertical);
static void __lambda8_ (CandidatePanel* self, CandidateArea* w, guint i, guint b, guint s);
static void ___lambda8__candidate_area_candidate_clicked (CandidateArea* _sender, guint index, guint button, guint state, gpointer self);
static void __lambda9_ (CandidatePanel* self, CandidateArea* c);
static void ___lambda9__candidate_area_page_up (CandidateArea* _sender, gpointer self);
static void __lambda10_ (CandidatePanel* self, CandidateArea* c);
static void ___lambda10__candidate_area_page_down (CandidateArea* _sender, gpointer self);
static void __lambda11_ (CandidatePanel* self, CandidateArea* c);
static void ___lambda11__candidate_area_cursor_up (CandidateArea* _sender, gpointer self);
static void __lambda12_ (CandidatePanel* self, CandidateArea* c);
static void ___lambda12__candidate_area_cursor_down (CandidateArea* _sender, gpointer self);
HSeparator* hseparator_new (void);
HSeparator* hseparator_construct (GType object_type);
static void candidate_panel_pack_all_widgets (CandidatePanel* self);
void candidate_panel_show (CandidatePanel* self);
void candidate_panel_hide (CandidatePanel* self);
static void candidate_panel_move (CandidatePanel* self, gint x, gint y);
static void g_cclosure_user_marshal_VOID__UINT_UINT_UINT (GClosure * closure, GValue * return_value, guint n_param_values, const GValue * param_values, gpointer invocation_hint, gpointer marshal_data);
static void candidate_panel_finalize (GObject* obj);
static void _vala_array_destroy (gpointer array, gint array_length, GDestroyNotify destroy_func);
static void _vala_array_free (gpointer array, gint array_length, GDestroyNotify destroy_func);


static gboolean __lambda7_ (CandidatePanel* self, GtkWidget* w, GdkEventButton* e) {
	gboolean result = FALSE;
	gboolean _tmp0_ = FALSE;
	GdkEventButton _tmp1_;
	guint _tmp2_;
	gboolean _tmp5_;
	gboolean _tmp6_;
	g_return_val_if_fail (w != NULL, FALSE);
	g_return_val_if_fail (e != NULL, FALSE);
	_tmp1_ = *e;
	_tmp2_ = _tmp1_.button;
	if (_tmp2_ != ((guint) 1)) {
		_tmp0_ = TRUE;
	} else {
		GdkEventButton _tmp3_;
		GdkModifierType _tmp4_;
		_tmp3_ = *e;
		_tmp4_ = _tmp3_.state;
		_tmp0_ = (_tmp4_ & GDK_CONTROL_MASK) == 0;
	}
	_tmp5_ = _tmp0_;
	if (_tmp5_) {
		result = FALSE;
		return result;
	}
	_tmp6_ = self->priv->m_vertical;
	candidate_panel_set_vertical (self, !_tmp6_);
	result = TRUE;
	return result;
}


static gboolean ___lambda7__gtk_widget_button_press_event (GtkWidget* _sender, GdkEventButton* event, gpointer self) {
	gboolean result;
	result = __lambda7_ (self, _sender, event);
	return result;
}


CandidatePanel* candidate_panel_construct (GType object_type) {
	CandidatePanel * self = NULL;
	GtkWindow* _tmp0_;
	GtkWindow* _tmp1_;
	GtkWindow* _tmp2_;
	Handle* _tmp3_;
	Handle* handle;
	GtkBox* _tmp4_;
	GtkBox* _tmp5_;
	GtkBox* _tmp6_;
	GtkWindow* _tmp7_;
	self = (CandidatePanel*) g_object_new (object_type, "name", "IBusCandidate", "visible", TRUE, NULL);
	_tmp0_ = (GtkWindow*) gtk_window_new (GTK_WINDOW_POPUP);
	g_object_ref_sink (_tmp0_);
	_g_object_unref0 (self->priv->m_toplevel);
	self->priv->m_toplevel = _tmp0_;
	_tmp1_ = self->priv->m_toplevel;
	gtk_widget_add_events ((GtkWidget*) _tmp1_, (gint) GDK_BUTTON_PRESS_MASK);
	_tmp2_ = self->priv->m_toplevel;
	g_signal_connect_object ((GtkWidget*) _tmp2_, "button-press-event", (GCallback) ___lambda7__gtk_widget_button_press_event, self, 0);
	_tmp3_ = handle_new ();
	g_object_ref_sink (_tmp3_);
	handle = _tmp3_;
	gtk_widget_set_visible ((GtkWidget*) handle, TRUE);
	gtk_box_pack_start ((GtkBox*) self, (GtkWidget*) handle, FALSE, FALSE, (guint) 0);
	_tmp4_ = (GtkBox*) gtk_box_new (GTK_ORIENTATION_VERTICAL, 0);
	g_object_ref_sink (_tmp4_);
	_g_object_unref0 (self->priv->m_vbox);
	self->priv->m_vbox = _tmp4_;
	_tmp5_ = self->priv->m_vbox;
	gtk_widget_set_visible ((GtkWidget*) _tmp5_, TRUE);
	_tmp6_ = self->priv->m_vbox;
	gtk_box_pack_start ((GtkBox*) self, (GtkWidget*) _tmp6_, FALSE, FALSE, (guint) 0);
	_tmp7_ = self->priv->m_toplevel;
	gtk_container_add ((GtkContainer*) _tmp7_, (GtkWidget*) self);
	candidate_panel_create_ui (self);
	_g_object_unref0 (handle);
	return self;
}


CandidatePanel* candidate_panel_new (void) {
	return candidate_panel_construct (TYPE_CANDIDATE_PANEL);
}


void candidate_panel_set_vertical (CandidatePanel* self, gboolean vertical) {
	gboolean _tmp0_;
	gboolean _tmp1_;
	gboolean _tmp2_;
	CandidateArea* _tmp3_;
	gboolean _tmp4_;
	g_return_if_fail (self != NULL);
	_tmp0_ = self->priv->m_vertical;
	_tmp1_ = vertical;
	if (_tmp0_ == _tmp1_) {
		return;
	}
	_tmp2_ = vertical;
	self->priv->m_vertical = _tmp2_;
	_tmp3_ = self->priv->m_candidate_area;
	_tmp4_ = vertical;
	candidate_area_set_vertical (_tmp3_, _tmp4_, FALSE);
}


static void candidate_panel_set_orientation (CandidatePanel* self, IBusOrientation orientation) {
	IBusOrientation _tmp0_;
	g_return_if_fail (self != NULL);
	_tmp0_ = orientation;
	switch (_tmp0_) {
		case IBUS_ORIENTATION_VERTICAL:
		{
			CandidateArea* _tmp1_;
			_tmp1_ = self->priv->m_candidate_area;
			candidate_area_set_vertical (_tmp1_, TRUE, FALSE);
			break;
		}
		case IBUS_ORIENTATION_HORIZONTAL:
		{
			CandidateArea* _tmp2_;
			_tmp2_ = self->priv->m_candidate_area;
			candidate_area_set_vertical (_tmp2_, FALSE, FALSE);
			break;
		}
		case IBUS_ORIENTATION_SYSTEM:
		{
			CandidateArea* _tmp3_;
			gboolean _tmp4_;
			_tmp3_ = self->priv->m_candidate_area;
			_tmp4_ = self->priv->m_vertical;
			candidate_area_set_vertical (_tmp3_, _tmp4_, FALSE);
			break;
		}
		default:
		break;
	}
}


static gboolean _cairo_rectangle_int_equal (const cairo_rectangle_int_t* s1, const cairo_rectangle_int_t* s2) {
	if (s1 == s2) {
		return TRUE;
	}
	if (s1 == NULL) {
		return FALSE;
	}
	if (s2 == NULL) {
		return FALSE;
	}
	if (s1->x != s2->x) {
		return FALSE;
	}
	if (s1->y != s2->y) {
		return FALSE;
	}
	if (s1->width != s2->width) {
		return FALSE;
	}
	if (s1->height != s2->height) {
		return FALSE;
	}
	return TRUE;
}


void candidate_panel_set_cursor_location (CandidatePanel* self, gint x, gint y, gint width, gint height) {
	gint _tmp0_;
	gint _tmp1_;
	gint _tmp2_;
	gint _tmp3_;
	GdkRectangle _tmp4_ = {0};
	GdkRectangle location;
	GdkRectangle _tmp5_;
	GdkRectangle _tmp6_;
	GdkRectangle _tmp7_;
	g_return_if_fail (self != NULL);
	_tmp0_ = x;
	_tmp1_ = y;
	_tmp2_ = width;
	_tmp3_ = height;
	memset (&_tmp4_, 0, sizeof (GdkRectangle));
	_tmp4_.x = _tmp0_;
	_tmp4_.y = _tmp1_;
	_tmp4_.width = _tmp2_;
	_tmp4_.height = _tmp3_;
	location = _tmp4_;
	_tmp5_ = self->priv->m_cursor_location;
	_tmp6_ = location;
	if (_cairo_rectangle_int_equal (&_tmp5_, &_tmp6_) == TRUE) {
		return;
	}
	_tmp7_ = location;
	self->priv->m_cursor_location = _tmp7_;
	candidate_panel_adjust_window_position (self);
}


static void candidate_panel_set_labels (CandidatePanel* self, IBusText** labels, int labels_length1) {
	CandidateArea* _tmp0_;
	IBusText** _tmp1_;
	gint _tmp1__length1;
	g_return_if_fail (self != NULL);
	_tmp0_ = self->priv->m_candidate_area;
	_tmp1_ = labels;
	_tmp1__length1 = labels_length1;
	candidate_area_set_labels (_tmp0_, _tmp1_, _tmp1__length1);
}


void candidate_panel_set_preedit_text (CandidatePanel* self, IBusText* text, guint cursor) {
	IBusText* _tmp0_;
	g_return_if_fail (self != NULL);
	_tmp0_ = text;
	if (_tmp0_ != NULL) {
		GtkLabel* _tmp1_;
		IBusText* _tmp2_;
		const gchar* _tmp3_ = NULL;
		GtkLabel* _tmp4_;
		_tmp1_ = self->priv->m_preedit_label;
		_tmp2_ = text;
		_tmp3_ = ibus_text_get_text (_tmp2_);
		gtk_label_set_text (_tmp1_, _tmp3_);
		_tmp4_ = self->priv->m_preedit_label;
		gtk_widget_show ((GtkWidget*) _tmp4_);
	} else {
		GtkLabel* _tmp5_;
		GtkLabel* _tmp6_;
		_tmp5_ = self->priv->m_preedit_label;
		gtk_label_set_text (_tmp5_, "");
		_tmp6_ = self->priv->m_preedit_label;
		gtk_widget_hide ((GtkWidget*) _tmp6_);
	}
	candidate_panel_update (self);
}


void candidate_panel_set_auxiliary_text (CandidatePanel* self, IBusText* text) {
	IBusText* _tmp0_;
	g_return_if_fail (self != NULL);
	_tmp0_ = text;
	if (_tmp0_ != NULL) {
		GtkLabel* _tmp1_;
		IBusText* _tmp2_;
		const gchar* _tmp3_ = NULL;
		GtkLabel* _tmp4_;
		_tmp1_ = self->priv->m_aux_label;
		_tmp2_ = text;
		_tmp3_ = ibus_text_get_text (_tmp2_);
		gtk_label_set_text (_tmp1_, _tmp3_);
		_tmp4_ = self->priv->m_aux_label;
		gtk_widget_show ((GtkWidget*) _tmp4_);
	} else {
		GtkLabel* _tmp5_;
		GtkLabel* _tmp6_;
		_tmp5_ = self->priv->m_aux_label;
		gtk_label_set_text (_tmp5_, "");
		_tmp6_ = self->priv->m_aux_label;
		gtk_widget_hide ((GtkWidget*) _tmp6_);
	}
	candidate_panel_update (self);
}


static gpointer _g_object_ref0 (gpointer self) {
	return self ? g_object_ref (self) : NULL;
}


static void _vala_array_add8 (IBusText*** array, int* length, int* size, IBusText* value) {
	if ((*length) == (*size)) {
		*size = (*size) ? (2 * (*size)) : 4;
		*array = g_renew (IBusText*, *array, (*size) + 1);
	}
	(*array)[(*length)++] = value;
	(*array)[*length] = NULL;
}


static void _vala_array_add9 (IBusText*** array, int* length, int* size, IBusText* value) {
	if ((*length) == (*size)) {
		*size = (*size) ? (2 * (*size)) : 4;
		*array = g_renew (IBusText*, *array, (*size) + 1);
	}
	(*array)[(*length)++] = value;
	(*array)[*length] = NULL;
}


void candidate_panel_set_lookup_table (CandidatePanel* self, IBusLookupTable* table) {
	IBusText** _tmp0_ = NULL;
	IBusText** candidates;
	gint candidates_length1;
	gint _candidates_size_;
	guint cursor_in_page;
	gboolean show_cursor;
	IBusText** _tmp1_ = NULL;
	IBusText** labels;
	gint labels_length1;
	gint _labels_size_;
	IBusOrientation orientation;
	IBusLookupTable* _tmp2_;
	CandidateArea* _tmp46_;
	IBusText** _tmp47_;
	gint _tmp47__length1;
	guint _tmp48_;
	gboolean _tmp49_;
	IBusText** _tmp50_;
	gint _tmp50__length1;
	IBusLookupTable* _tmp51_;
	IBusText** _tmp53_;
	gint _tmp53__length1;
	g_return_if_fail (self != NULL);
	_tmp0_ = g_new0 (IBusText*, 0 + 1);
	candidates = _tmp0_;
	candidates_length1 = 0;
	_candidates_size_ = candidates_length1;
	cursor_in_page = (guint) 0;
	show_cursor = TRUE;
	_tmp1_ = g_new0 (IBusText*, 0 + 1);
	labels = _tmp1_;
	labels_length1 = 0;
	_labels_size_ = labels_length1;
	orientation = IBUS_ORIENTATION_SYSTEM;
	_tmp2_ = table;
	if (_tmp2_ != NULL) {
		IBusLookupTable* _tmp3_;
		guint _tmp4_ = 0U;
		guint page_size;
		IBusLookupTable* _tmp5_;
		guint _tmp6_ = 0U;
		guint ncandidates;
		IBusLookupTable* _tmp7_;
		guint _tmp8_ = 0U;
		guint cursor;
		IBusLookupTable* _tmp9_;
		guint _tmp10_ = 0U;
		IBusLookupTable* _tmp11_;
		gboolean _tmp12_ = FALSE;
		guint _tmp13_;
		guint _tmp14_;
		guint _tmp15_;
		guint page_start_pos;
		guint _tmp16_;
		guint _tmp17_;
		guint _tmp18_;
		guint _tmp19_ = 0U;
		guint page_end_pos;
		IBusLookupTable* _tmp44_;
		gint _tmp45_ = 0;
		_tmp3_ = table;
		_tmp4_ = ibus_lookup_table_get_page_size (_tmp3_);
		page_size = _tmp4_;
		_tmp5_ = table;
		_tmp6_ = ibus_lookup_table_get_number_of_candidates (_tmp5_);
		ncandidates = _tmp6_;
		_tmp7_ = table;
		_tmp8_ = ibus_lookup_table_get_cursor_pos (_tmp7_);
		cursor = _tmp8_;
		_tmp9_ = table;
		_tmp10_ = ibus_lookup_table_get_cursor_in_page (_tmp9_);
		cursor_in_page = _tmp10_;
		_tmp11_ = table;
		_tmp12_ = ibus_lookup_table_is_cursor_visible (_tmp11_);
		show_cursor = _tmp12_;
		_tmp13_ = cursor;
		_tmp14_ = page_size;
		_tmp15_ = page_size;
		page_start_pos = (_tmp13_ / _tmp14_) * _tmp15_;
		_tmp16_ = page_start_pos;
		_tmp17_ = page_size;
		_tmp18_ = ncandidates;
		_tmp19_ = MIN (_tmp16_ + _tmp17_, _tmp18_);
		page_end_pos = _tmp19_;
		{
			guint _tmp20_;
			guint i;
			_tmp20_ = page_start_pos;
			i = _tmp20_;
			{
				gboolean _tmp21_;
				_tmp21_ = TRUE;
				while (TRUE) {
					gboolean _tmp22_;
					guint _tmp24_;
					guint _tmp25_;
					IBusText** _tmp26_;
					gint _tmp26__length1;
					IBusLookupTable* _tmp27_;
					guint _tmp28_;
					IBusText* _tmp29_ = NULL;
					IBusText* _tmp30_;
					_tmp22_ = _tmp21_;
					if (!_tmp22_) {
						guint _tmp23_;
						_tmp23_ = i;
						i = _tmp23_ + 1;
					}
					_tmp21_ = FALSE;
					_tmp24_ = i;
					_tmp25_ = page_end_pos;
					if (!(_tmp24_ < _tmp25_)) {
						break;
					}
					_tmp26_ = candidates;
					_tmp26__length1 = candidates_length1;
					_tmp27_ = table;
					_tmp28_ = i;
					_tmp29_ = ibus_lookup_table_get_candidate (_tmp27_, _tmp28_);
					_tmp30_ = _g_object_ref0 (_tmp29_);
					_vala_array_add8 (&candidates, &candidates_length1, &_candidates_size_, _tmp30_);
				}
			}
		}
		{
			guint i;
			i = (guint) 0;
			{
				gboolean _tmp31_;
				_tmp31_ = TRUE;
				while (TRUE) {
					gboolean _tmp32_;
					guint _tmp34_;
					guint _tmp35_;
					IBusLookupTable* _tmp36_;
					guint _tmp37_;
					IBusText* _tmp38_ = NULL;
					IBusText* _tmp39_;
					IBusText* label;
					IBusText* _tmp40_;
					_tmp32_ = _tmp31_;
					if (!_tmp32_) {
						guint _tmp33_;
						_tmp33_ = i;
						i = _tmp33_ + 1;
					}
					_tmp31_ = FALSE;
					_tmp34_ = i;
					_tmp35_ = page_size;
					if (!(_tmp34_ < _tmp35_)) {
						break;
					}
					_tmp36_ = table;
					_tmp37_ = i;
					_tmp38_ = ibus_lookup_table_get_label (_tmp36_, _tmp37_);
					_tmp39_ = _g_object_ref0 (_tmp38_);
					label = _tmp39_;
					_tmp40_ = label;
					if (_tmp40_ != NULL) {
						IBusText** _tmp41_;
						gint _tmp41__length1;
						IBusText* _tmp42_;
						IBusText* _tmp43_;
						_tmp41_ = labels;
						_tmp41__length1 = labels_length1;
						_tmp42_ = label;
						_tmp43_ = _g_object_ref0 (_tmp42_);
						_vala_array_add9 (&labels, &labels_length1, &_labels_size_, _tmp43_);
					}
					_g_object_unref0 (label);
				}
			}
		}
		_tmp44_ = table;
		_tmp45_ = ibus_lookup_table_get_orientation (_tmp44_);
		orientation = (IBusOrientation) _tmp45_;
	}
	_tmp46_ = self->priv->m_candidate_area;
	_tmp47_ = candidates;
	_tmp47__length1 = candidates_length1;
	_tmp48_ = cursor_in_page;
	_tmp49_ = show_cursor;
	candidate_area_set_candidates (_tmp46_, _tmp47_, _tmp47__length1, _tmp48_, _tmp49_);
	_tmp50_ = labels;
	_tmp50__length1 = labels_length1;
	candidate_panel_set_labels (self, _tmp50_, _tmp50__length1);
	_tmp51_ = table;
	if (_tmp51_ != NULL) {
		IBusOrientation _tmp52_;
		_tmp52_ = orientation;
		candidate_panel_set_orientation (self, _tmp52_);
	}
	_tmp53_ = candidates;
	_tmp53__length1 = candidates_length1;
	if (_tmp53__length1 != 0) {
		CandidateArea* _tmp54_;
		_tmp54_ = self->priv->m_candidate_area;
		gtk_widget_show_all ((GtkWidget*) _tmp54_);
	} else {
		CandidateArea* _tmp55_;
		_tmp55_ = self->priv->m_candidate_area;
		gtk_widget_hide ((GtkWidget*) _tmp55_);
	}
	candidate_panel_update (self);
	labels = (_vala_array_free (labels, labels_length1, (GDestroyNotify) g_object_unref), NULL);
	candidates = (_vala_array_free (candidates, candidates_length1, (GDestroyNotify) g_object_unref), NULL);
}


static void candidate_panel_update (CandidatePanel* self) {
	gboolean _tmp0_ = FALSE;
	gboolean _tmp1_ = FALSE;
	CandidateArea* _tmp2_;
	gboolean _tmp3_ = FALSE;
	gboolean _tmp6_;
	gboolean _tmp9_;
	gboolean _tmp12_ = FALSE;
	GtkLabel* _tmp13_;
	gboolean _tmp14_ = FALSE;
	gboolean _tmp21_;
	g_return_if_fail (self != NULL);
	_tmp2_ = self->priv->m_candidate_area;
	_tmp3_ = gtk_widget_get_visible ((GtkWidget*) _tmp2_);
	if (_tmp3_) {
		_tmp1_ = TRUE;
	} else {
		GtkLabel* _tmp4_;
		gboolean _tmp5_ = FALSE;
		_tmp4_ = self->priv->m_preedit_label;
		_tmp5_ = gtk_widget_get_visible ((GtkWidget*) _tmp4_);
		_tmp1_ = _tmp5_;
	}
	_tmp6_ = _tmp1_;
	if (_tmp6_) {
		_tmp0_ = TRUE;
	} else {
		GtkLabel* _tmp7_;
		gboolean _tmp8_ = FALSE;
		_tmp7_ = self->priv->m_aux_label;
		_tmp8_ = gtk_widget_get_visible ((GtkWidget*) _tmp7_);
		_tmp0_ = _tmp8_;
	}
	_tmp9_ = _tmp0_;
	if (_tmp9_) {
		GtkWindow* _tmp10_;
		_tmp10_ = self->priv->m_toplevel;
		gtk_widget_show ((GtkWidget*) _tmp10_);
	} else {
		GtkWindow* _tmp11_;
		_tmp11_ = self->priv->m_toplevel;
		gtk_widget_hide ((GtkWidget*) _tmp11_);
	}
	_tmp13_ = self->priv->m_aux_label;
	_tmp14_ = gtk_widget_get_visible ((GtkWidget*) _tmp13_);
	if (_tmp14_) {
		gboolean _tmp15_ = FALSE;
		CandidateArea* _tmp16_;
		gboolean _tmp17_ = FALSE;
		gboolean _tmp20_;
		_tmp16_ = self->priv->m_candidate_area;
		_tmp17_ = gtk_widget_get_visible ((GtkWidget*) _tmp16_);
		if (_tmp17_) {
			_tmp15_ = TRUE;
		} else {
			GtkLabel* _tmp18_;
			gboolean _tmp19_ = FALSE;
			_tmp18_ = self->priv->m_preedit_label;
			_tmp19_ = gtk_widget_get_visible ((GtkWidget*) _tmp18_);
			_tmp15_ = _tmp19_;
		}
		_tmp20_ = _tmp15_;
		_tmp12_ = _tmp20_;
	} else {
		_tmp12_ = FALSE;
	}
	_tmp21_ = _tmp12_;
	if (_tmp21_) {
		HSeparator* _tmp22_;
		_tmp22_ = self->priv->m_hseparator;
		gtk_widget_show ((GtkWidget*) _tmp22_);
	} else {
		HSeparator* _tmp23_;
		_tmp23_ = self->priv->m_hseparator;
		gtk_widget_hide ((GtkWidget*) _tmp23_);
	}
}


static void candidate_panel_real_get_preferred_width (GtkWidget* base, gint* minimum_width, gint* natural_width) {
	CandidatePanel * self;
	gint _vala_minimum_width = 0;
	gint _vala_natural_width = 0;
	gint _tmp0_ = 0;
	gint _tmp1_ = 0;
	GtkWindow* _tmp2_;
	self = (CandidatePanel*) base;
	GTK_WIDGET_CLASS (candidate_panel_parent_class)->get_preferred_width ((GtkWidget*) G_TYPE_CHECK_INSTANCE_CAST (self, GTK_TYPE_HBOX, GtkHBox), &_tmp0_, &_tmp1_);
	_vala_minimum_width = _tmp0_;
	_vala_natural_width = _tmp1_;
	_tmp2_ = self->priv->m_toplevel;
	gtk_window_resize (_tmp2_, 1, 1);
	if (minimum_width) {
		*minimum_width = _vala_minimum_width;
	}
	if (natural_width) {
		*natural_width = _vala_natural_width;
	}
}


static void candidate_panel_real_get_preferred_height (GtkWidget* base, gint* minimum_width, gint* natural_width) {
	CandidatePanel * self;
	gint _vala_minimum_width = 0;
	gint _vala_natural_width = 0;
	gint _tmp0_ = 0;
	gint _tmp1_ = 0;
	GtkWindow* _tmp2_;
	self = (CandidatePanel*) base;
	GTK_WIDGET_CLASS (candidate_panel_parent_class)->get_preferred_height ((GtkWidget*) G_TYPE_CHECK_INSTANCE_CAST (self, GTK_TYPE_HBOX, GtkHBox), &_tmp0_, &_tmp1_);
	_vala_minimum_width = _tmp0_;
	_vala_natural_width = _tmp1_;
	_tmp2_ = self->priv->m_toplevel;
	gtk_window_resize (_tmp2_, 1, 1);
	if (minimum_width) {
		*minimum_width = _vala_minimum_width;
	}
	if (natural_width) {
		*natural_width = _vala_natural_width;
	}
}


static void __lambda8_ (CandidatePanel* self, CandidateArea* w, guint i, guint b, guint s) {
	guint _tmp0_;
	guint _tmp1_;
	guint _tmp2_;
	g_return_if_fail (w != NULL);
	_tmp0_ = i;
	_tmp1_ = b;
	_tmp2_ = s;
	g_signal_emit_by_name (self, "candidate-clicked", _tmp0_, _tmp1_, _tmp2_);
}


static void ___lambda8__candidate_area_candidate_clicked (CandidateArea* _sender, guint index, guint button, guint state, gpointer self) {
	__lambda8_ (self, _sender, index, button, state);
}


static void __lambda9_ (CandidatePanel* self, CandidateArea* c) {
	g_return_if_fail (c != NULL);
	g_signal_emit_by_name (self, "page-up");
}


static void ___lambda9__candidate_area_page_up (CandidateArea* _sender, gpointer self) {
	__lambda9_ (self, _sender);
}


static void __lambda10_ (CandidatePanel* self, CandidateArea* c) {
	g_return_if_fail (c != NULL);
	g_signal_emit_by_name (self, "page-down");
}


static void ___lambda10__candidate_area_page_down (CandidateArea* _sender, gpointer self) {
	__lambda10_ (self, _sender);
}


static void __lambda11_ (CandidatePanel* self, CandidateArea* c) {
	g_return_if_fail (c != NULL);
	g_signal_emit_by_name (self, "cursor-up");
}


static void ___lambda11__candidate_area_cursor_up (CandidateArea* _sender, gpointer self) {
	__lambda11_ (self, _sender);
}


static void __lambda12_ (CandidatePanel* self, CandidateArea* c) {
	g_return_if_fail (c != NULL);
	g_signal_emit_by_name (self, "cursor-down");
}


static void ___lambda12__candidate_area_cursor_down (CandidateArea* _sender, gpointer self) {
	__lambda12_ (self, _sender);
}


static void candidate_panel_create_ui (CandidatePanel* self) {
	GtkLabel* _tmp0_;
	GtkLabel* _tmp1_;
	GtkLabel* _tmp2_;
	GtkLabel* _tmp3_;
	GtkLabel* _tmp4_;
	GtkLabel* _tmp5_;
	GtkLabel* _tmp6_;
	GtkLabel* _tmp7_;
	GtkLabel* _tmp8_;
	GtkLabel* _tmp9_;
	gboolean _tmp10_;
	CandidateArea* _tmp11_;
	CandidateArea* _tmp12_;
	CandidateArea* _tmp13_;
	CandidateArea* _tmp14_;
	CandidateArea* _tmp15_;
	CandidateArea* _tmp16_;
	HSeparator* _tmp17_;
	HSeparator* _tmp18_;
	g_return_if_fail (self != NULL);
	_tmp0_ = (GtkLabel*) gtk_label_new (NULL);
	g_object_ref_sink (_tmp0_);
	_g_object_unref0 (self->priv->m_preedit_label);
	self->priv->m_preedit_label = _tmp0_;
	_tmp1_ = self->priv->m_preedit_label;
	gtk_widget_set_size_request ((GtkWidget*) _tmp1_, 20, -1);
	_tmp2_ = self->priv->m_preedit_label;
	gtk_misc_set_alignment ((GtkMisc*) _tmp2_, 0.0f, 0.5f);
	_tmp3_ = self->priv->m_preedit_label;
	gtk_misc_set_padding ((GtkMisc*) _tmp3_, 8, 0);
	_tmp4_ = self->priv->m_preedit_label;
	gtk_widget_set_no_show_all ((GtkWidget*) _tmp4_, TRUE);
	_tmp5_ = (GtkLabel*) gtk_label_new (NULL);
	g_object_ref_sink (_tmp5_);
	_g_object_unref0 (self->priv->m_aux_label);
	self->priv->m_aux_label = _tmp5_;
	_tmp6_ = self->priv->m_aux_label;
	gtk_widget_set_size_request ((GtkWidget*) _tmp6_, 20, -1);
	_tmp7_ = self->priv->m_aux_label;
	gtk_misc_set_alignment ((GtkMisc*) _tmp7_, 0.0f, 0.5f);
	_tmp8_ = self->priv->m_aux_label;
	gtk_misc_set_padding ((GtkMisc*) _tmp8_, 8, 0);
	_tmp9_ = self->priv->m_aux_label;
	gtk_widget_set_no_show_all ((GtkWidget*) _tmp9_, TRUE);
	_tmp10_ = self->priv->m_vertical;
	_tmp11_ = candidate_area_new (_tmp10_);
	g_object_ref_sink (_tmp11_);
	_g_object_unref0 (self->priv->m_candidate_area);
	self->priv->m_candidate_area = _tmp11_;
	_tmp12_ = self->priv->m_candidate_area;
	g_signal_connect_object (_tmp12_, "candidate-clicked", (GCallback) ___lambda8__candidate_area_candidate_clicked, self, 0);
	_tmp13_ = self->priv->m_candidate_area;
	g_signal_connect_object (_tmp13_, "page-up", (GCallback) ___lambda9__candidate_area_page_up, self, 0);
	_tmp14_ = self->priv->m_candidate_area;
	g_signal_connect_object (_tmp14_, "page-down", (GCallback) ___lambda10__candidate_area_page_down, self, 0);
	_tmp15_ = self->priv->m_candidate_area;
	g_signal_connect_object (_tmp15_, "cursor-up", (GCallback) ___lambda11__candidate_area_cursor_up, self, 0);
	_tmp16_ = self->priv->m_candidate_area;
	g_signal_connect_object (_tmp16_, "cursor-down", (GCallback) ___lambda12__candidate_area_cursor_down, self, 0);
	_tmp17_ = hseparator_new ();
	g_object_ref_sink (_tmp17_);
	_g_object_unref0 (self->priv->m_hseparator);
	self->priv->m_hseparator = _tmp17_;
	_tmp18_ = self->priv->m_hseparator;
	gtk_widget_set_visible ((GtkWidget*) _tmp18_, TRUE);
	candidate_panel_pack_all_widgets (self);
}


static void candidate_panel_pack_all_widgets (CandidatePanel* self) {
	GtkBox* _tmp0_;
	GtkLabel* _tmp1_;
	GtkBox* _tmp2_;
	GtkLabel* _tmp3_;
	GtkBox* _tmp4_;
	HSeparator* _tmp5_;
	GtkBox* _tmp6_;
	CandidateArea* _tmp7_;
	g_return_if_fail (self != NULL);
	_tmp0_ = self->priv->m_vbox;
	_tmp1_ = self->priv->m_preedit_label;
	gtk_box_pack_start (_tmp0_, (GtkWidget*) _tmp1_, FALSE, FALSE, (guint) 4);
	_tmp2_ = self->priv->m_vbox;
	_tmp3_ = self->priv->m_aux_label;
	gtk_box_pack_start (_tmp2_, (GtkWidget*) _tmp3_, FALSE, FALSE, (guint) 4);
	_tmp4_ = self->priv->m_vbox;
	_tmp5_ = self->priv->m_hseparator;
	gtk_box_pack_start (_tmp4_, (GtkWidget*) _tmp5_, FALSE, FALSE, (guint) 0);
	_tmp6_ = self->priv->m_vbox;
	_tmp7_ = self->priv->m_candidate_area;
	gtk_box_pack_start (_tmp6_, (GtkWidget*) _tmp7_, FALSE, FALSE, (guint) 0);
}


void candidate_panel_show (CandidatePanel* self) {
	GtkWindow* _tmp0_;
	g_return_if_fail (self != NULL);
	_tmp0_ = self->priv->m_toplevel;
	gtk_widget_show_all ((GtkWidget*) _tmp0_);
}


void candidate_panel_hide (CandidatePanel* self) {
	GtkWindow* _tmp0_;
	g_return_if_fail (self != NULL);
	_tmp0_ = self->priv->m_toplevel;
	gtk_widget_hide ((GtkWidget*) _tmp0_);
}


static void candidate_panel_move (CandidatePanel* self, gint x, gint y) {
	GtkWindow* _tmp0_;
	gint _tmp1_;
	gint _tmp2_;
	g_return_if_fail (self != NULL);
	_tmp0_ = self->priv->m_toplevel;
	_tmp1_ = x;
	_tmp2_ = y;
	gtk_window_move (_tmp0_, _tmp1_, _tmp2_);
}


static void candidate_panel_adjust_window_position (CandidatePanel* self) {
	GdkRectangle _tmp0_;
	gint _tmp1_;
	GdkRectangle _tmp2_;
	gint _tmp3_;
	GdkRectangle _tmp4_;
	gint _tmp5_;
	GdkRectangle _tmp6_;
	gint _tmp7_;
	GdkPoint _tmp8_ = {0};
	GdkPoint cursor_right_bottom;
	GtkAllocation allocation = {0};
	GtkWindow* _tmp9_;
	GtkAllocation _tmp10_ = {0};
	GdkPoint _tmp11_;
	gint _tmp12_;
	GtkAllocation _tmp13_;
	gint _tmp14_;
	GdkPoint _tmp15_;
	gint _tmp16_;
	GtkAllocation _tmp17_;
	gint _tmp18_;
	GdkPoint _tmp19_ = {0};
	GdkPoint window_right_bottom;
	GdkWindow* _tmp20_ = NULL;
	GdkWindow* _tmp21_;
	GdkWindow* root;
	GdkWindow* _tmp22_;
	gint _tmp23_ = 0;
	gint root_width;
	GdkWindow* _tmp24_;
	gint _tmp25_ = 0;
	gint root_height;
	gint x = 0;
	gint y = 0;
	GdkPoint _tmp26_;
	gint _tmp27_;
	gint _tmp28_;
	GdkPoint _tmp34_;
	gint _tmp35_;
	gint _tmp36_;
	gint _tmp43_;
	gint _tmp44_;
	g_return_if_fail (self != NULL);
	_tmp0_ = self->priv->m_cursor_location;
	_tmp1_ = _tmp0_.x;
	_tmp2_ = self->priv->m_cursor_location;
	_tmp3_ = _tmp2_.width;
	_tmp4_ = self->priv->m_cursor_location;
	_tmp5_ = _tmp4_.y;
	_tmp6_ = self->priv->m_cursor_location;
	_tmp7_ = _tmp6_.height;
	_tmp8_.x = _tmp1_ + _tmp3_;
	_tmp8_.y = _tmp5_ + _tmp7_;
	cursor_right_bottom = _tmp8_;
	_tmp9_ = self->priv->m_toplevel;
	gtk_widget_get_allocation ((GtkWidget*) _tmp9_, &_tmp10_);
	allocation = _tmp10_;
	_tmp11_ = cursor_right_bottom;
	_tmp12_ = _tmp11_.x;
	_tmp13_ = allocation;
	_tmp14_ = _tmp13_.width;
	_tmp15_ = cursor_right_bottom;
	_tmp16_ = _tmp15_.y;
	_tmp17_ = allocation;
	_tmp18_ = _tmp17_.height;
	_tmp19_.x = _tmp12_ + _tmp14_;
	_tmp19_.y = _tmp16_ + _tmp18_;
	window_right_bottom = _tmp19_;
	_tmp20_ = gdk_get_default_root_window ();
	_tmp21_ = _g_object_ref0 (_tmp20_);
	root = _tmp21_;
	_tmp22_ = root;
	_tmp23_ = gdk_window_get_width (_tmp22_);
	root_width = _tmp23_;
	_tmp24_ = root;
	_tmp25_ = gdk_window_get_height (_tmp24_);
	root_height = _tmp25_;
	_tmp26_ = window_right_bottom;
	_tmp27_ = _tmp26_.x;
	_tmp28_ = root_width;
	if (_tmp27_ > _tmp28_) {
		gint _tmp29_;
		GtkAllocation _tmp30_;
		gint _tmp31_;
		_tmp29_ = root_width;
		_tmp30_ = allocation;
		_tmp31_ = _tmp30_.width;
		x = _tmp29_ - _tmp31_;
	} else {
		GdkPoint _tmp32_;
		gint _tmp33_;
		_tmp32_ = cursor_right_bottom;
		_tmp33_ = _tmp32_.x;
		x = _tmp33_;
	}
	_tmp34_ = window_right_bottom;
	_tmp35_ = _tmp34_.y;
	_tmp36_ = root_height;
	if (_tmp35_ > _tmp36_) {
		GdkRectangle _tmp37_;
		gint _tmp38_;
		GtkAllocation _tmp39_;
		gint _tmp40_;
		_tmp37_ = self->priv->m_cursor_location;
		_tmp38_ = _tmp37_.y;
		_tmp39_ = allocation;
		_tmp40_ = _tmp39_.height;
		y = _tmp38_ - _tmp40_;
	} else {
		GdkPoint _tmp41_;
		gint _tmp42_;
		_tmp41_ = cursor_right_bottom;
		_tmp42_ = _tmp41_.y;
		y = _tmp42_;
	}
	_tmp43_ = x;
	_tmp44_ = y;
	candidate_panel_move (self, _tmp43_, _tmp44_);
	_g_object_unref0 (root);
}


static void g_cclosure_user_marshal_VOID__UINT_UINT_UINT (GClosure * closure, GValue * return_value, guint n_param_values, const GValue * param_values, gpointer invocation_hint, gpointer marshal_data) {
	typedef void (*GMarshalFunc_VOID__UINT_UINT_UINT) (gpointer data1, guint arg_1, guint arg_2, guint arg_3, gpointer data2);
	register GMarshalFunc_VOID__UINT_UINT_UINT callback;
	register GCClosure * cc;
	register gpointer data1;
	register gpointer data2;
	cc = (GCClosure *) closure;
	g_return_if_fail (n_param_values == 4);
	if (G_CCLOSURE_SWAP_DATA (closure)) {
		data1 = closure->data;
		data2 = param_values->data[0].v_pointer;
	} else {
		data1 = param_values->data[0].v_pointer;
		data2 = closure->data;
	}
	callback = (GMarshalFunc_VOID__UINT_UINT_UINT) (marshal_data ? marshal_data : cc->callback);
	callback (data1, g_value_get_uint (param_values + 1), g_value_get_uint (param_values + 2), g_value_get_uint (param_values + 3), data2);
}


static void candidate_panel_class_init (CandidatePanelClass * klass) {
	candidate_panel_parent_class = g_type_class_peek_parent (klass);
	g_type_class_add_private (klass, sizeof (CandidatePanelPrivate));
	GTK_WIDGET_CLASS (klass)->get_preferred_width = candidate_panel_real_get_preferred_width;
	GTK_WIDGET_CLASS (klass)->get_preferred_height = candidate_panel_real_get_preferred_height;
	G_OBJECT_CLASS (klass)->finalize = candidate_panel_finalize;
	g_signal_new ("cursor_up", TYPE_CANDIDATE_PANEL, G_SIGNAL_RUN_LAST, 0, NULL, NULL, g_cclosure_marshal_VOID__VOID, G_TYPE_NONE, 0);
	g_signal_new ("cursor_down", TYPE_CANDIDATE_PANEL, G_SIGNAL_RUN_LAST, 0, NULL, NULL, g_cclosure_marshal_VOID__VOID, G_TYPE_NONE, 0);
	g_signal_new ("page_up", TYPE_CANDIDATE_PANEL, G_SIGNAL_RUN_LAST, 0, NULL, NULL, g_cclosure_marshal_VOID__VOID, G_TYPE_NONE, 0);
	g_signal_new ("page_down", TYPE_CANDIDATE_PANEL, G_SIGNAL_RUN_LAST, 0, NULL, NULL, g_cclosure_marshal_VOID__VOID, G_TYPE_NONE, 0);
	g_signal_new ("candidate_clicked", TYPE_CANDIDATE_PANEL, G_SIGNAL_RUN_LAST, 0, NULL, NULL, g_cclosure_user_marshal_VOID__UINT_UINT_UINT, G_TYPE_NONE, 3, G_TYPE_UINT, G_TYPE_UINT, G_TYPE_UINT);
}


static void candidate_panel_instance_init (CandidatePanel * self) {
	self->priv = CANDIDATE_PANEL_GET_PRIVATE (self);
	self->priv->m_vertical = TRUE;
}


static void candidate_panel_finalize (GObject* obj) {
	CandidatePanel * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (obj, TYPE_CANDIDATE_PANEL, CandidatePanel);
	_g_object_unref0 (self->priv->m_toplevel);
	_g_object_unref0 (self->priv->m_vbox);
	_g_object_unref0 (self->priv->m_preedit_label);
	_g_object_unref0 (self->priv->m_aux_label);
	_g_object_unref0 (self->priv->m_candidate_area);
	_g_object_unref0 (self->priv->m_hseparator);
	G_OBJECT_CLASS (candidate_panel_parent_class)->finalize (obj);
}


GType candidate_panel_get_type (void) {
	static volatile gsize candidate_panel_type_id__volatile = 0;
	if (g_once_init_enter (&candidate_panel_type_id__volatile)) {
		static const GTypeInfo g_define_type_info = { sizeof (CandidatePanelClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) candidate_panel_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (CandidatePanel), 0, (GInstanceInitFunc) candidate_panel_instance_init, NULL };
		GType candidate_panel_type_id;
		candidate_panel_type_id = g_type_register_static (GTK_TYPE_HBOX, "CandidatePanel", &g_define_type_info, 0);
		g_once_init_leave (&candidate_panel_type_id__volatile, candidate_panel_type_id);
	}
	return candidate_panel_type_id__volatile;
}


static void _vala_array_destroy (gpointer array, gint array_length, GDestroyNotify destroy_func) {
	if ((array != NULL) && (destroy_func != NULL)) {
		int i;
		for (i = 0; i < array_length; i = i + 1) {
			if (((gpointer*) array)[i] != NULL) {
				destroy_func (((gpointer*) array)[i]);
			}
		}
	}
}


static void _vala_array_free (gpointer array, gint array_length, GDestroyNotify destroy_func) {
	_vala_array_destroy (array, array_length, destroy_func);
	g_free (array);
}



